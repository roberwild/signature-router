<?xml version="1.0" encoding="UTF-8"?>
<story-context id="3-9-provider-retry-logic" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.9</storyId>
    <title>Provider Retry Logic</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-28</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-9-provider-retry-logic.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Sistema de Signature Router</asA>
    <iWant>Lógica de retry robusta con exponential backoff para provider calls</iWant>
    <soThat>Puedo recuperarme de fallos transitorios sin intervención manual y mejorar la tasa de éxito</soThat>
    <tasks>
      - Task 1: Configure Resilience4j Retry Instances (1h)
      - Task 2: Apply @Retry Annotations to Providers (1h)
      - Task 3: Enhance ProviderResult with Retry Metadata (45min)
      - Task 4: Implement Prometheus Retry Metrics (1h)
      - Task 5: Unit Tests - Retry Logic per Provider (1h 30min)
      - Task 6: Integration Tests - End-to-End Retry Flow (1h 30min)
      - Task 7: Logging Enhancement for Retry Events (45min)
      - Task 8: Documentation and Runbook (45min)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">
      <description>Resilience4j Retry configurado en application.yml con 4 instancias: smsRetry (maxAttempts=3, waitDuration=1s, multiplier=2), pushRetry (maxAttempts=3, waitDuration=500ms, multiplier=2), voiceRetry (maxAttempts=2, waitDuration=2s, multiplier=2), biometricRetry (maxAttempts=1)</description>
    </criterion>
    <criterion id="AC2">
      <description>Cada provider implementa retry logic con @Retry annotation en método sendChallenge(), retry name basado en provider type, sin fallback method (Epic 4)</description>
    </criterion>
    <criterion id="AC3">
      <description>Exponential backoff configurable per-provider: SMS (1s→2s→4s, max 7s), Push (500ms→1s→2s, max 3.5s), Voice (2s→4s, max 6s), Biometric (sin retry)</description>
    </criterion>
    <criterion id="AC4">
      <description>Retry solo en exceptions transient: IOException, TimeoutException, ApiException(5xx), FCM UNAVAILABLE/INTERNAL. NO retry en ApiException(4xx), FCM INVALID_ARGUMENT/UNREGISTERED</description>
    </criterion>
    <criterion id="AC5">
      <description>Métricas Prometheus: provider.retry.attempts.total{provider, attempt}, provider.retry.success.total{provider, after_attempts}, provider.retry.exhausted.total{provider}, provider.retry.duration{provider}</description>
    </criterion>
    <criterion id="AC6">
      <description>ProviderResult incluye retry metadata: int attemptNumber (1=first attempt, 2=1 retry), boolean retriedSuccess, factory methods successAfterRetry() y retryExhausted()</description>
    </criterion>
    <criterion id="AC7">
      <description>Logging detallado: log.warn() en retry attempts, log.info() en success after retry, log.error() en retry exhausted, todos con traceId</description>
    </criterion>
    <criterion id="AC8">
      <description>Idempotency safety: TwilioSmsProvider idempotent (Twilio deduplica To+From+Body 4h), PushNotificationProvider idempotent (FCM message_id), VoiceCallProvider idempotent, BiometricProvider no retry</description>
    </criterion>
    <criterion id="AC9">
      <description>Multi-environment config: application-local.yml (maxAttempts=5 aggressive), application-uat.yml (maxAttempts=3 production-like), application-prod.yml (maxAttempts=3 conservative)</description>
    </criterion>
    <criterion id="AC10">
      <description>Retry + Timeout interaction: Timeout aplica per-attempt NO acumulativo, TimeoutException triggers retry si está en retryExceptions</description>
    </criterion>
    <criterion id="AC11">
      <description>Retry aware de Circuit Breaker: Retry NO ejecuta si Circuit Breaker OPEN (Epic 4), implementar check en retry predicate, log.debug cuando skip</description>
    </criterion>
    <criterion id="AC12">
      <description>Distributed tracing: Cada retry attempt mantiene mismo traceId, span per-attempt con tags retry.attempt, retry.max, total retry duration en span</description>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification</title>
        <section>Provider Retry Logic (Story 3.9)</section>
        <snippet>Resilience4j Retry integration con exponential backoff, retry policies específicos per-provider (SMS: 3 attempts 1s backoff, Push: 3 attempts 500ms, Voice: 2 attempts 2s, Biometric: 1 no retry). Exception classification: retryable (IOException, TimeoutException, 5xx) vs non-retryable (4xx, authentication failures)</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/3-8-provider-timeout-configuration.md</path>
        <title>Story 3.8: Provider Timeout Configuration</title>
        <section>Learnings and Architecture</section>
        <snippet>Async provider methods con CompletableFuture pattern, TimeLimiter integration, ProviderResult enhanced con campo timedOut. Retry aplicará DESPUÉS de timeout per-attempt. Multi-environment configuration strategy validada (local/uat/prod)</snippet>
      </doc>
      <doc>
        <path>docs/architecture/06-resilience-strategy.md</path>
        <title>Resilience Strategy</title>
        <section>Retry Configuration</section>
        <snippet>Resilience4j retry instances configurables: providerRetry, databaseRetry, kafkaRetry. Exponential backoff multiplier, retryExceptions, ignoreExceptions. Integration con fallback chains (Epic 4)</snippet>
      </doc>
      <doc>
        <path>docs/architecture/07-observability-security.md</path>
        <title>Observability & Security</title>
        <section>Provider Metrics</section>
        <snippet>ProviderMetrics component con Counter, Timer, Gauge. Pattern establecido: providerCalls, providerErrors, providerLatency con tags provider, status. Registro con MeterRegistry</snippet>
      </doc>
      <doc>
        <path>docs/architecture/02-hexagonal-structure.md</path>
        <title>Hexagonal Structure</title>
        <section>Infrastructure Layer - Resilience</section>
        <snippet>Resilience4j integration en infrastructure/resilience/ package. CircuitBreakerManager, ProviderHealthMonitor, DegradedModeManager. Annotations @Retry, @TimeLimiter, @CircuitBreaker en infrastructure adapters, NO en domain</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
        <kind>domain-value-object</kind>
        <symbol>ProviderResult</symbol>
        <lines>1-179</lines>
        <reason>Record que necesita enhancement con campos attemptNumber y retriedSuccess. Ya tiene timedOut field de Story 3.8. Factory methods success(), failure(), timeout() existentes - agregar successAfterRetry() y retryExhausted()</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/twilio/TwilioSmsProvider.java</path>
        <kind>infrastructure-provider</kind>
        <symbol>TwilioSmsProvider</symbol>
        <lines>68-115</lines>
        <reason>Provider que necesita @Retry(name="smsRetry") annotation. Método sendChallenge() debe capturar attemptNumber de RetryContext. Pattern de metrics con Timer.Sample y MeterRegistry ya establecido - reutilizar para retry metrics</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/push/PushNotificationProvider.java</path>
        <kind>infrastructure-provider</kind>
        <symbol>PushNotificationProvider</symbol>
        <lines>73-132</lines>
        <reason>Provider FCM que necesita @Retry(name="pushRetry"). Exception predicate para filtrar FirebaseMessagingException UNAVAILABLE/INTERNAL (retryable) vs INVALID_ARGUMENT/UNREGISTERED (non-retryable)</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/voice/VoiceCallProvider.java</path>
        <kind>infrastructure-provider</kind>
        <symbol>VoiceCallProvider</symbol>
        <lines>118-158</lines>
        <reason>Provider Voice que necesita @Retry(name="voiceRetry", maxAttempts=2). Twilio ApiException handling ya establecido - agregar retry logic</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/SignatureProviderAdapter.java</path>
        <kind>infrastructure-adapter</kind>
        <symbol>SignatureProviderAdapter</symbol>
        <lines>21-75</lines>
        <reason>Adapter que orquesta provider calls con TimeLimiter. Puede necesitar integración con RetryRegistry para metrics access. Ya tiene MeterRegistry injection - reutilizar</reason>
      </artifact>
      <artifact>
        <path>src/main/resources/application.yml</path>
        <kind>configuration</kind>
        <symbol>resilience4j.retry</symbol>
        <lines>132-141</lines>
        <reason>Configuración existente de Resilience4j retry twilioProvider. Necesita expansion a 4 instances: smsRetry, pushRetry, voiceRetry, biometricRetry con configs específicos</reason>
      </artifact>
      <artifact>
        <path>src/main/resources/application.yml</path>
        <kind>configuration</kind>
        <symbol>resilience4j.timelimiter</symbol>
        <lines>143-165</lines>
        <reason>TimeLimiter config de Story 3.8. Retry interaction: timeout aplica per-attempt. TimeoutException debe estar en retryExceptions para trigger retry</reason>
      </artifact>
      <artifact>
        <path>src/test/java/com/bank/signature/domain/model/valueobject/ProviderResultTest.java</path>
        <kind>test-unit</kind>
        <symbol>ProviderResultTest</symbol>
        <lines>1-56</lines>
        <reason>Test existente para ProviderResult. Pattern establecido con AssertJ assertions. Agregar tests para new factory methods: successAfterRetry(), retryExhausted()</reason>
      </artifact>
    </code>

    <dependencies>
      <maven>
        <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
          <scope>compile</scope>
          <note>Ya incluido de Story 2.5. Contiene resilience4j-retry module</note>
        </dependency>
        <dependency>
          <groupId>io.github.resilience4j</groupId>
          <artifactId>resilience4j-micrometer</artifactId>
          <scope>compile</scope>
          <note>Ya incluido. Exporta retry metrics a Prometheus vía MeterRegistry</note>
        </dependency>
        <dependency>
          <groupId>com.twilio.sdk</groupId>
          <artifactId>twilio</artifactId>
          <version>9.14.1</version>
          <note>Twilio SDK para clasificar ApiException status codes (4xx vs 5xx)</note>
        </dependency>
        <dependency>
          <groupId>com.google.firebase</groupId>
          <artifactId>firebase-admin</artifactId>
          <version>9.2.0</version>
          <note>Firebase Admin SDK - FirebaseMessagingException error codes para retry predicate</note>
        </dependency>
      </maven>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="ARCH-1">
      <description>Domain Layer Purity: ProviderResult es domain value object - NO agregar dependencias de Resilience4j. Solo agregar campos primitivos (int attemptNumber, boolean retriedSuccess)</description>
    </constraint>
    <constraint id="ARCH-2">
      <description>Hexagonal Architecture: @Retry annotations SOLO en infrastructure providers, NUNCA en domain services o application use cases</description>
    </constraint>
    <constraint id="RETRY-1">
      <description>Idempotency Safety: SOLO agregar @Retry en providers confirmados idempotentes (TwilioSmsProvider, PushNotificationProvider, VoiceCallProvider). BiometricProvider maxAttempts=1 (no retry)</description>
    </constraint>
    <constraint id="RETRY-2">
      <description>Exception Classification: Retry SOLO en transient failures (IOException, TimeoutException, 5xx server errors). NO retry en permanent failures (4xx client errors, authentication errors)</description>
    </constraint>
    <constraint id="RETRY-3">
      <description>Exponential Backoff: waitDuration × exponentialBackoffMultiplier^attemptNumber. SMS: 1s base, multiplier 2 → 1s, 2s, 4s. Configurar en application.yml, NO hardcoded</description>
    </constraint>
    <constraint id="RETRY-4">
      <description>Timeout Interaction: Timeout (Story 3.8) aplica PER-ATTEMPT, NO acumulativo. Total possible latency: maxAttempts × timeout + sum(backoff delays)</description>
    </constraint>
    <constraint id="METRICS-1">
      <description>Metrics Naming Convention: provider.retry.{metric}.total format. Tags: provider (SMS|PUSH|VOICE), attempt (1|2|3), after_attempts (1|2|3). Seguir pattern establecido en ProviderMetrics</description>
    </constraint>
    <constraint id="LOGGING-1">
      <description>Structured Logging: MDC traceId MUST propagate across retry attempts. Log levels: WARN for retry attempts, INFO for success after retry, ERROR for exhausted retries</description>
    </constraint>
    <constraint id="MULTI-ENV-1">
      <description>Environment Strategy: application-local.yml aggressive retries (maxAttempts=5 for testing), application-prod.yml conservative (maxAttempts=3, fast backoff). Seguir pattern de Story 3.8</description>
    </constraint>
    <constraint id="EPIC4-PREP-1">
      <description>Circuit Breaker Preparation: Retry predicate debe incluir placeholder check para circuit breaker state. Comment: // TODO Epic 4: Check circuit breaker state before retry. Bean injection ready para CircuitBreakerRegistry</description>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>ProviderResult Enhanced</name>
      <kind>domain-value-object</kind>
      <signature>
        public record ProviderResult(
            boolean success,
            String providerChallengeId,
            String providerProof,
            String errorCode,
            String errorMessage,
            Instant timestamp,
            boolean timedOut,        // Story 3.8
            int attemptNumber,       // NEW Story 3.9 - default 1
            boolean retriedSuccess   // NEW Story 3.9 - default false
        )
      </signature>
      <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
    </interface>
    <interface>
      <name>ProviderResult.successAfterRetry</name>
      <kind>factory-method</kind>
      <signature>
        public static ProviderResult successAfterRetry(
            String providerChallengeId, 
            String providerProof, 
            int attempts
        )
      </signature>
      <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
    </interface>
    <interface>
      <name>ProviderResult.retryExhausted</name>
      <kind>factory-method</kind>
      <signature>
        public static ProviderResult retryExhausted(
            String errorCode, 
            String errorMessage, 
            int attempts
        )
      </signature>
      <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
    </interface>
    <interface>
      <name>RetryExceptionPredicate</name>
      <kind>component-class</kind>
      <signature>
        @Component
        public class RetryExceptionPredicate implements Predicate&lt;Throwable&gt; {
            @Override
            public boolean test(Throwable throwable) {
                // Classify exceptions: retryable vs non-retryable
                // Twilio: retry 5xx, NOT 4xx
                // FCM: retry UNAVAILABLE/INTERNAL, NOT INVALID_ARGUMENT/UNREGISTERED
            }
        }
      </signature>
      <path>src/main/java/com/bank/signature/infrastructure/resilience/RetryExceptionPredicate.java</path>
    </interface>
    <interface>
      <name>RetryEventListener</name>
      <kind>component-class</kind>
      <signature>
        @Component
        public class RetryEventListener {
            @EventListener
            public void onRetryEvent(RetryOnRetryEvent event) {
                // Log retry attempt with traceId
                // Publish retry metrics
            }
            
            @EventListener
            public void onSuccessEvent(RetryOnSuccessEvent event) {
                // Log success after retries
            }
            
            @EventListener
            public void onErrorEvent(RetryOnErrorEvent event) {
                // Log retry exhausted
            }
        }
      </signature>
      <path>src/main/java/com/bank/signature/infrastructure/resilience/RetryEventListener.java</path>
    </interface>
    <interface>
      <name>ProviderRetryMetrics</name>
      <kind>component-class</kind>
      <signature>
        @Component
        public class ProviderRetryMetrics {
            public void recordRetryAttempt(String provider, int attemptNumber);
            public void recordRetrySuccess(String provider, int totalAttempts);
            public void recordRetryExhausted(String provider, int totalAttempts);
        }
      </signature>
      <path>src/main/java/com/bank/signature/infrastructure/observability/metrics/ProviderRetryMetrics.java</path>
    </interface>
    <interface>
      <name>Resilience4j Retry Configuration</name>
      <kind>configuration-yaml</kind>
      <signature>
        resilience4j:
          retry:
            configs:
              default:
                maxAttempts: 3
                waitDuration: 1s
                exponentialBackoffMultiplier: 2
                retryExceptions:
                  - java.io.IOException
                  - java.util.concurrent.TimeoutException
            instances:
              smsRetry:
                baseConfig: default
                maxAttempts: 3
                waitDuration: 1s
              pushRetry:
                baseConfig: default
                maxAttempts: 3
                waitDuration: 500ms
              voiceRetry:
                baseConfig: default
                maxAttempts: 2
                waitDuration: 2s
              biometricRetry:
                maxAttempts: 1
                waitDuration: 0s
      </signature>
      <path>src/main/resources/application.yml</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing strategy sigue patrón establecido en Story 3.8: Unit tests con JUnit 5 + AssertJ, mock Resilience4j RetryContext para capture attemptNumber. Integration tests con @SpringBootTest + Testcontainers, mock provider con WireMock para simular transient failures. Coverage target >85%, metrics validation via /actuator/prometheus endpoint.
    </standards>
    <locations>
      - src/test/java/com/bank/signature/domain/model/valueobject/ (ProviderResult unit tests)
      - src/test/java/com/bank/signature/infrastructure/adapter/outbound/provider/ (Provider retry unit + integration tests)
      - src/test/java/com/bank/signature/infrastructure/resilience/ (RetryEventListener, RetryExceptionPredicate tests)
      - src/test/java/com/bank/signature/infrastructure/observability/metrics/ (ProviderRetryMetrics tests)
    </locations>
    <ideas>
      <testIdea ac="AC1">
        <description>Integration test: Verificar que Resilience4j carga 4 retry instances desde application.yml con configs correctos (maxAttempts, waitDuration, multiplier). Usar @SpringBootTest + inject RetryRegistry</description>
      </testIdea>
      <testIdea ac="AC2">
        <description>Unit test TwilioSmsProviderRetryTest: Mock provider throw IOException on attempts 1-2, success on attempt 3. Verify method called 3 times, ProviderResult.attemptNumber=3, retriedSuccess=true</description>
      </testIdea>
      <testIdea ac="AC3">
        <description>Integration test: Mock provider con transient failure, measure duration between retry attempts. Verify exponential backoff timing: ~1s wait, then ~2s wait para SMS retry</description>
      </testIdea>
      <testIdea ac="AC4">
        <description>Unit test RetryExceptionPredicateTest: Verify Twilio ApiException(503) retryable, ApiException(400) non-retryable. FCM FirebaseMessagingException UNAVAILABLE retryable, INVALID_ARGUMENT non-retryable</description>
      </testIdea>
      <testIdea ac="AC5">
        <description>Integration test: Trigger retry flow, call /actuator/prometheus, verify metrics present: provider_retry_attempts_total{provider="SMS",attempt="1"}, provider_retry_success_total{after_attempts="3"}</description>
      </testIdea>
      <testIdea ac="AC6">
        <description>Unit test ProviderResultRetryTest: Test factory methods successAfterRetry(id, proof, 3) creates result with attemptNumber=3, retriedSuccess=true. Test retryExhausted(code, msg, 3) creates failure with attemptNumber=3</description>
      </testIdea>
      <testIdea ac="AC7">
        <description>Unit test RetryEventListenerTest: Mock RetryOnRetryEvent, verify log.warn() called with traceId, attemptNumber. Use Logback test appender to capture log statements</description>
      </testIdea>
      <testIdea ac="AC8">
        <description>Documentation test: Verify Twilio SMS idempotency guarantee en docs (4h deduplication window). Confirm FCM message_id based deduplication. BiometricProvider maxAttempts=1 configured</description>
      </testIdea>
      <testIdea ac="AC9">
        <description>Integration test: @ActiveProfiles("local") verify maxAttempts=5 from application-local.yml. @ActiveProfiles("prod") verify maxAttempts=3 from application-prod.yml</description>
      </testIdea>
      <testIdea ac="AC10">
        <description>Integration test: Mock provider timeout on attempt 1 (5s), success on attempt 2. Measure total duration ~5s (timeout) + 1s (backoff) + 2s (success) = ~8s. Verify timeout triggers retry</description>
      </testIdea>
      <testIdea ac="AC11">
        <description>Unit test (preparación Epic 4): Verify retry predicate tiene placeholder check para circuit breaker. Comment present: "TODO Epic 4: Check circuit breaker state". Bean injection ready</description>
      </testIdea>
      <testIdea ac="AC12">
        <description>Integration test: Start retry flow con traceId="test-123", verify todas las retry attempts tienen mismo traceId en MDC. Check span tags: retry.attempt, retry.max presente</description>
      </testIdea>
    </ideas>
  </tests>
</story-context>
