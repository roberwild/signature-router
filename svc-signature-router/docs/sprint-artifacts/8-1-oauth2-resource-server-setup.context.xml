<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context: 8.1 - OAuth2 Resource Server Setup
  Epic: Epic 8 - Security & Compliance
  Created: 2025-11-29
  Status: Ready for Development
  
  This context file provides all necessary information for implementing Story 8.1:
  OAuth2 Resource Server with JWT validation and Keycloak integration.
-->

<story-context>
  <metadata>
    <story-id>8.1</story-id>
    <story-key>8-1-oauth2-resource-server-setup</story-key>
    <epic-id>epic-8</epic-id>
    <epic-name>Security &amp; Compliance</epic-name>
    <priority>CRITICAL</priority>
    <estimation>5 SP</estimation>
    <duration>1-2 days</duration>
    <status>ready-for-dev</status>
    <created-date>2025-11-29</created-date>
  </metadata>

  <!--
    ============================================================================
    DOCUMENTATION ARTIFACTS
    ============================================================================
    Relevant documentation from previous work that provides context for this story.
  -->
  <documentation-artifacts>
    
    <!-- Artifact 1: Tech Spec Epic 8 - Story 8.1 Section -->
    <artifact id="tech-spec-epic-8-story-8.1">
      <name>Tech Spec Epic 8 - Story 8.1: OAuth2 Resource Server Setup</name>
      <path>docs/sprint-artifacts/tech-spec-epic-8.md</path>
      <section>Story-by-Story Technical Details → Story 8.1</section>
      <relevant-content>
        <goal>Integrar OAuth2 Resource Server con Keycloak para validación de JWT tokens en todos los endpoints</goal>
        <acceptance-criteria>
          <ac>AC1: Spring Security OAuth2 Resource Server dependency added</ac>
          <ac>AC2: Keycloak configuration in application.yml (issuer-uri, jwk-set-uri)</ac>
          <ac>AC3: SecurityFilterChain with OAuth2 JWT validation (stateless, CSRF disabled)</ac>
          <ac>AC4: JWT Authentication Converter (roles extraction from realm_access.roles)</ac>
          <ac>AC5-AC8: Integration tests (valid JWT → 200, missing → 401, expired → 401, invalid signature → 401)</ac>
          <ac>AC9: Public endpoints accessible without JWT (Swagger, Actuator)</ac>
        </acceptance-criteria>
        <technical-design>
          <keycloak-config>
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8080/realms/signature-router
          jwk-set-uri: http://localhost:8080/realms/signature-router/protocol/openid-connect/certs
          </keycloak-config>
          <security-filter-chain>
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) {
    return http
        .csrf(csrf -> csrf.disable()) // Stateless JWT
        .sessionManagement(session -> session
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
            .requestMatchers("/actuator/health", "/actuator/prometheus").permitAll()
            .requestMatchers("/api/v1/**").authenticated()
            .anyRequest().denyAll())
        .oauth2ResourceServer(oauth2 -> oauth2
            .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter())))
        .build();
}
          </security-filter-chain>
          <jwt-converter>
@Component
public class KeycloakJwtAuthenticationConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection&lt;GrantedAuthority&gt; authorities = extractAuthorities(jwt);
        String username = jwt.getClaimAsString("preferred_username");
        return new JwtAuthenticationToken(jwt, authorities, username);
    }
    
    private Collection&lt;GrantedAuthority&gt; extractAuthorities(Jwt jwt) {
        Map&lt;String, Object&gt; realmAccess = jwt.getClaim("realm_access");
        if (realmAccess == null) return List.of();
        
        List&lt;String&gt; roles = (List&lt;String&gt;) realmAccess.get("roles");
        return roles.stream()
            .map(role -> new SimpleGrantedAuthority("ROLE_" + role.toUpperCase()))
            .collect(Collectors.toList());
    }
}
          </jwt-converter>
        </technical-design>
      </relevant-content>
    </artifact>

    <!-- Artifact 2: PRD Security Requirements -->
    <artifact id="prd-security-nfr-s1-s4">
      <name>PRD - Security Requirements NFR-S1 to NFR-S4</name>
      <path>docs/prd.md</path>
      <section>Non-Functional Requirements → Security</section>
      <relevant-content>
        <nfr id="NFR-S1">JWT tokens con RSA 256 signature mínimo</nfr>
        <nfr id="NFR-S2">Tokens expiran en 1 hora (access) o 30 días (refresh)</nfr>
        <nfr id="NFR-S3">RBAC enforcement en todos los endpoints</nfr>
        <nfr id="NFR-S4">API keys rotables para service-to-service auth</nfr>
        <compliance>PCI-DSS Req 8, SOC 2 CC6.1, GDPR Art. 32</compliance>
      </relevant-content>
    </artifact>

    <!-- Artifact 3: Architecture - Observability &amp; Security -->
    <artifact id="architecture-security">
      <name>Architecture - Observability &amp; Security</name>
      <path>docs/architecture/07-observability-security.md</path>
      <section>Security Strategy</section>
      <relevant-content>
        <authentication>OAuth2 Resource Server with JWT tokens from Keycloak</authentication>
        <authorization>RBAC with 4 roles: ADMIN, AUDITOR, SUPPORT, USER</authorization>
        <session-management>Stateless (NO server-side sessions, JWT only)</session-management>
        <public-endpoints>Swagger UI, Actuator health/prometheus (NO authentication)</public-endpoints>
      </relevant-content>
    </artifact>

    <!-- Artifact 4: Story 1.7 - REST API Foundation &amp; Security (Base) -->
    <artifact id="story-1.7-security-config">
      <name>Story 1.7 - REST API Foundation &amp; Security</name>
      <path>docs/sprint-artifacts/1-7-rest-api-foundation-security.md</path>
      <section>Security Configuration</section>
      <relevant-content>
        <note>Story 1.7 implemented BASE SecurityConfig WITHOUT OAuth2 Resource Server</note>
        <note>Story 8.1 EXTENDS Story 1.7 by adding OAuth2 JWT validation</note>
        <existing-security-config>
          <file>src/main/java/com/bank/signature/infrastructure/config/SecurityConfig.java</file>
          <status>EXISTS - MODIFY to add OAuth2 Resource Server</status>
        </existing-security-config>
      </relevant-content>
    </artifact>

    <!-- Artifact 5: Keycloak Realm Configuration -->
    <artifact id="keycloak-realm-config">
      <name>Keycloak Realm Configuration</name>
      <path>keycloak/realms/signature-router-realm.json</path>
      <section>Realm Definition</section>
      <relevant-content>
        <realm-name>signature-router</realm-name>
        <client-id>signature-router-backend</client-id>
        <roles>
          <role>ADMIN</role>
          <role>AUDITOR</role>
          <role>SUPPORT</role>
          <role>USER</role>
        </roles>
        <access-token-lifespan>3600 seconds (1 hour)</access-token-lifespan>
        <refresh-token-lifespan>2592000 seconds (30 days)</refresh-token-lifespan>
        <note>Keycloak already configured in keycloak/realms/signature-router-realm.json</note>
        <note>Import command: docker exec keycloak /opt/keycloak/bin/kc.sh import --file /tmp/signature-router-realm.json</note>
      </relevant-content>
    </artifact>

  </documentation-artifacts>

  <!--
    ============================================================================
    CODE ARTIFACTS
    ============================================================================
    Code templates, examples, and existing code that will be used or modified.
  -->
  <code-artifacts>

    <!-- Code Artifact 1: KeycloakJwtAuthenticationConverter (NEW) -->
    <artifact id="keycloak-jwt-converter">
      <name>KeycloakJwtAuthenticationConverter.java</name>
      <path>src/main/java/com/bank/signature/infrastructure/security/KeycloakJwtAuthenticationConverter.java</path>
      <type>NEW</type>
      <language>java</language>
      <purpose>Convert JWT to Spring Security authentication token with roles extraction</purpose>
      <template>
package com.bank.signature.infrastructure.security;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Converts Keycloak JWT to Spring Security authentication token.
 * Extracts roles from 'realm_access.roles' claim and maps to ROLE_* authorities.
 * 
 * &lt;p&gt;Example JWT claim:&lt;/p&gt;
 * &lt;pre&gt;
 * {
 *   "realm_access": {
 *     "roles": ["admin", "user"]
 *   }
 * }
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;Mapped authorities: ROLE_ADMIN, ROLE_USER&lt;/p&gt;
 * 
 * @see org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
 * @since 1.0.0 (Epic 8 - Story 8.1)
 */
@Component
public class KeycloakJwtAuthenticationConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    
    private static final String ROLE_PREFIX = "ROLE_";
    private static final String REALM_ACCESS_CLAIM = "realm_access";
    private static final String ROLES_CLAIM = "roles";
    private static final String PREFERRED_USERNAME_CLAIM = "preferred_username";
    
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection&lt;GrantedAuthority&gt; authorities = extractAuthorities(jwt);
        String username = jwt.getClaimAsString(PREFERRED_USERNAME_CLAIM);
        return new JwtAuthenticationToken(jwt, authorities, username);
    }
    
    @SuppressWarnings("unchecked")
    private Collection&lt;GrantedAuthority&gt; extractAuthorities(Jwt jwt) {
        Map&lt;String, Object&gt; realmAccess = jwt.getClaim(REALM_ACCESS_CLAIM);
        if (realmAccess == null) {
            return Collections.emptyList();
        }
        
        List&lt;String&gt; roles = (List&lt;String&gt;) realmAccess.get(ROLES_CLAIM);
        if (roles == null || roles.isEmpty()) {
            return Collections.emptyList();
        }
        
        return roles.stream()
            .map(role -> new SimpleGrantedAuthority(ROLE_PREFIX + role.toUpperCase()))
            .collect(Collectors.toList());
    }
}
      </template>
    </artifact>

    <!-- Code Artifact 2: SecurityConfig.java (MODIFY) -->
    <artifact id="security-config">
      <name>SecurityConfig.java</name>
      <path>src/main/java/com/bank/signature/infrastructure/config/SecurityConfig.java</path>
      <type>MODIFY</type>
      <language>java</language>
      <purpose>Update SecurityFilterChain to add OAuth2 Resource Server with JWT validation</purpose>
      <modification-instructions>
        <step>1. Add @Autowired KeycloakJwtAuthenticationConverter</step>
        <step>2. Update securityFilterChain() method to add oauth2ResourceServer() configuration</step>
        <step>3. Keep existing CSRF disabled, stateless session, public endpoints</step>
        <step>4. Add .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter)))</step>
      </modification-instructions>
      <template>
package com.bank.signature.infrastructure.config;

import com.bank.signature.infrastructure.security.KeycloakJwtAuthenticationConverter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

/**
 * Spring Security configuration for OAuth2 Resource Server with JWT validation.
 * 
 * &lt;p&gt;Security rules:&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Public endpoints: /swagger-ui/**, /v3/api-docs/**, /actuator/health, /actuator/prometheus&lt;/li&gt;
 *   &lt;li&gt;Protected endpoints: /api/v1/** (requires valid JWT token)&lt;/li&gt;
 *   &lt;li&gt;Default: Deny all (anyRequest().denyAll())&lt;/li&gt;
 *   &lt;li&gt;Session: STATELESS (no server-side sessions)&lt;/li&gt;
 *   &lt;li&gt;CSRF: Disabled (stateless JWT)&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @see KeycloakJwtAuthenticationConverter
 * @since 1.0.0 (Story 1.7 base, Story 8.1 OAuth2)
 */
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Autowired
    private KeycloakJwtAuthenticationConverter jwtAuthenticationConverter;
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .requestMatchers("/actuator/health", "/actuator/prometheus").permitAll()
                .requestMatchers("/api/v1/**").authenticated()
                .anyRequest().denyAll())
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter)))
            .build();
    }
}
      </template>
    </artifact>

    <!-- Code Artifact 3: application.yml (MODIFY) -->
    <artifact id="application-yml">
      <name>application.yml</name>
      <path>src/main/resources/application.yml</path>
      <type>MODIFY</type>
      <language>yaml</language>
      <purpose>Add OAuth2 Resource Server configuration</purpose>
      <template>
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${KEYCLOAK_ISSUER_URI}
          jwk-set-uri: ${KEYCLOAK_JWK_SET_URI}

management:
  endpoints:
    web:
      exposure:
        include: health,prometheus
      </template>
    </artifact>

    <!-- Code Artifact 4: application-local.yml (MODIFY) -->
    <artifact id="application-local-yml">
      <name>application-local.yml</name>
      <path>src/main/resources/application-local.yml</path>
      <type>MODIFY</type>
      <language>yaml</language>
      <purpose>Keycloak localhost configuration for development</purpose>
      <template>
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8080/realms/signature-router
          jwk-set-uri: http://localhost:8080/realms/signature-router/protocol/openid-connect/certs

logging:
  level:
    org.springframework.security: DEBUG
    org.springframework.security.oauth2: DEBUG
      </template>
    </artifact>

    <!-- Code Artifact 5: application-uat.yml (MODIFY) -->
    <artifact id="application-uat-yml">
      <name>application-uat.yml</name>
      <path>src/main/resources/application-uat.yml</path>
      <type>MODIFY</type>
      <language>yaml</language>
      <purpose>Keycloak UAT configuration</purpose>
      <template>
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://keycloak-uat.bank.com/realms/signature-router
          jwk-set-uri: https://keycloak-uat.bank.com/realms/signature-router/protocol/openid-connect/certs
      </template>
    </artifact>

    <!-- Code Artifact 6: application-prod.yml (MODIFY) -->
    <artifact id="application-prod-yml">
      <name>application-prod.yml</name>
      <path>src/main/resources/application-prod.yml</path>
      <type>MODIFY</type>
      <language>yaml</language>
      <purpose>Keycloak Production configuration</purpose>
      <template>
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://keycloak.bank.com/realms/signature-router
          jwk-set-uri: https://keycloak.bank.com/realms/signature-router/protocol/openid-connect/certs
      </template>
    </artifact>

    <!-- Code Artifact 7: get-token.sh (NEW) -->
    <artifact id="get-token-script">
      <name>get-token.sh</name>
      <path>keycloak/get-token.sh</path>
      <type>NEW</type>
      <language>bash</language>
      <purpose>Helper script to get JWT token from Keycloak for testing</purpose>
      <template>
#!/bin/bash
# Helper script to get JWT token from Keycloak for testing
# Usage: ./get-token.sh [username] [password]

set -e

KEYCLOAK_URL=${KEYCLOAK_URL:-http://localhost:8080}
REALM=${REALM:-signature-router}
CLIENT_ID=${CLIENT_ID:-signature-router-backend}
CLIENT_SECRET=${CLIENT_SECRET:-YOUR_CLIENT_SECRET}
USERNAME=${1:-admin@bank.com}
PASSWORD=${2:-admin123}

echo "Getting JWT token from Keycloak..."
echo "Realm: $REALM"
echo "Username: $USERNAME"

RESPONSE=$(curl -s -X POST \
  "$KEYCLOAK_URL/realms/$REALM/protocol/openid-connect/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "client_id=$CLIENT_ID" \
  -d "client_secret=$CLIENT_SECRET" \
  -d "grant_type=password" \
  -d "username=$USERNAME" \
  -d "password=$PASSWORD")

ACCESS_TOKEN=$(echo $RESPONSE | jq -r '.access_token')
REFRESH_TOKEN=$(echo $RESPONSE | jq -r '.refresh_token')
EXPIRES_IN=$(echo $RESPONSE | jq -r '.expires_in')

if [ "$ACCESS_TOKEN" != "null" ]; then
    echo ""
    echo "✅ JWT Token obtained successfully!"
    echo ""
    echo "Access Token (valid for $EXPIRES_IN seconds):"
    echo "$ACCESS_TOKEN"
    echo ""
    echo "Export to environment:"
    echo "export TOKEN='$ACCESS_TOKEN'"
    echo ""
    echo "Use in curl:"
    echo "curl -H 'Authorization: Bearer $ACCESS_TOKEN' http://localhost:8080/api/v1/signatures"
else
    echo "❌ Failed to get token"
    echo "Response: $RESPONSE"
    exit 1
fi
      </template>
    </artifact>

    <!-- Code Artifact 8: OAuth2SecurityIntegrationTest.java (NEW) -->
    <artifact id="oauth2-security-integration-test">
      <name>OAuth2SecurityIntegrationTest.java</name>
      <path>src/test/java/com/bank/signature/infrastructure/security/OAuth2SecurityIntegrationTest.java</path>
      <type>NEW</type>
      <language>java</language>
      <purpose>Integration tests for OAuth2 JWT authentication</purpose>
      <template>
package com.bank.signature.infrastructure.security;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.time.Instant;

import static org.hamcrest.Matchers.containsString;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Integration tests for OAuth2 Resource Server with JWT authentication.
 * 
 * &lt;p&gt;Tests:&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;AC5: Valid JWT → HTTP 200&lt;/li&gt;
 *   &lt;li&gt;AC6: Missing JWT → HTTP 401&lt;/li&gt;
 *   &lt;li&gt;AC7: Expired JWT → HTTP 401&lt;/li&gt;
 *   &lt;li&gt;AC8: Invalid JWT signature → HTTP 401&lt;/li&gt;
 *   &lt;li&gt;AC9: Public endpoints without JWT → HTTP 200&lt;/li&gt;
 * &lt;/ul&gt;
 */
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
class OAuth2SecurityIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    // AC5: Valid JWT → 200
    @Test
    void testApiWithValidJwt_Returns200() throws Exception {
        mockMvc.perform(get("/api/v1/signatures")
            .with(jwt()
                .authorities(new SimpleGrantedAuthority("ROLE_USER"))
                .jwt(jwt -> jwt.claim("preferred_username", "test-user"))))
            .andExpect(status().isOk());
    }
    
    // AC6: Missing JWT → 401
    @Test
    void testApiWithoutJwt_Returns401() throws Exception {
        mockMvc.perform(get("/api/v1/signatures"))
            .andExpect(status().isUnauthorized())
            .andExpect(header().exists("WWW-Authenticate"));
    }
    
    // AC7: Expired JWT → 401
    @Test
    void testApiWithExpiredJwt_Returns401() throws Exception {
        Jwt expiredJwt = Jwt.withTokenValue("expired-token")
            .header("alg", "RS256")
            .claim("sub", "user123")
            .claim("exp", Instant.now().minusSeconds(3600)) // Expired 1h ago
            .build();
        
        mockMvc.perform(get("/api/v1/signatures")
            .with(jwt(expiredJwt)))
            .andExpect(status().isUnauthorized());
    }
    
    // AC8: Invalid signature → 401
    @Test
    void testApiWithInvalidSignature_Returns401() throws Exception {
        String tamperedToken = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.TAMPERED.INVALID_SIGNATURE";
        
        mockMvc.perform(get("/api/v1/signatures")
            .header("Authorization", "Bearer " + tamperedToken))
            .andExpect(status().isUnauthorized());
    }
    
    // AC9: Public endpoints without JWT → 200
    @Test
    void testSwaggerUiWithoutJwt_Returns200() throws Exception {
        mockMvc.perform(get("/swagger-ui/index.html"))
            .andExpect(status().isOk());
    }
    
    @Test
    void testActuatorHealthWithoutJwt_Returns200() throws Exception {
        mockMvc.perform(get("/actuator/health"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.status").value("UP"));
    }
    
    @Test
    void testActuatorPrometheusWithoutJwt_Returns200() throws Exception {
        mockMvc.perform(get("/actuator/prometheus"))
            .andExpect(status().isOk())
            .andExpect(content().string(containsString("jvm_memory_used_bytes")));
    }
}
      </template>
    </artifact>

  </code-artifacts>

  <!--
    ============================================================================
    MAVEN DEPENDENCIES
    ============================================================================
  -->
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
      <scope>compile</scope>
      <version>Managed by Spring Boot BOM</version>
      <note>OAuth2 Resource Server with JWT support</note>
    </dependency>
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-test</artifactId>
      <scope>test</scope>
      <version>Managed by Spring Boot BOM</version>
      <note>Spring Security test utilities (MockMvc jwt() support)</note>
    </dependency>
  </dependencies>

  <!--
    ============================================================================
    CONSTRAINTS
    ============================================================================
    Implementation constraints, rules, and best practices.
  -->
  <constraints>
    
    <!-- Security Constraints -->
    <constraint id="SEC-1" type="SECURITY" priority="CRITICAL">
      <rule>JWT validation MUST use RSA 256 asymmetric keys (NO HS256 symmetric keys)</rule>
      <rationale>RSA 256 prevents token forgery (only Keycloak has private key)</rationale>
      <validation>Keycloak JWKS endpoint returns RSA public keys (kty: RSA, alg: RS256)</validation>
    </constraint>

    <constraint id="SEC-2" type="SECURITY" priority="CRITICAL">
      <rule>Session management MUST be STATELESS (NO server-side sessions)</rule>
      <rationale>JWT is self-contained, no need for server-side session storage</rationale>
      <validation>SessionCreationPolicy.STATELESS in SecurityFilterChain</validation>
    </constraint>

    <constraint id="SEC-3" type="SECURITY" priority="HIGH">
      <rule>CSRF protection MUST be disabled for stateless JWT</rule>
      <rationale>CSRF attacks require session cookies, JWT in Authorization header is immune</rationale>
      <validation>.csrf(csrf -> csrf.disable()) in SecurityFilterChain</validation>
    </constraint>

    <constraint id="SEC-4" type="SECURITY" priority="HIGH">
      <rule>Public endpoints (Swagger, Actuator) MUST NOT require JWT</rule>
      <rationale>Health checks and API documentation should be publicly accessible</rationale>
      <validation>.requestMatchers("/swagger-ui/**", "/actuator/**").permitAll()</validation>
    </constraint>

    <constraint id="SEC-5" type="SECURITY" priority="CRITICAL">
      <rule>Protected endpoints (/api/v1/**) MUST require valid JWT</rule>
      <rationale>Business APIs must be authenticated</rationale>
      <validation>.requestMatchers("/api/v1/**").authenticated()</validation>
    </constraint>

    <constraint id="SEC-6" type="SECURITY" priority="HIGH">
      <rule>Default policy MUST be deny-all (fail-safe)</rule>
      <rationale>Explicitly deny all other requests not matched by rules</rationale>
      <validation>.anyRequest().denyAll()</validation>
    </constraint>

    <!-- JWT Constraints -->
    <constraint id="JWT-1" type="JWT" priority="CRITICAL">
      <rule>Roles MUST be extracted from 'realm_access.roles' claim</rule>
      <rationale>Keycloak stores realm-level roles in this claim</rationale>
      <validation>KeycloakJwtAuthenticationConverter extracts Map&lt;String, Object&gt; realmAccess = jwt.getClaim("realm_access")</validation>
    </constraint>

    <constraint id="JWT-2" type="JWT" priority="HIGH">
      <rule>Roles MUST be prefixed with 'ROLE_' and UPPERCASED</rule>
      <rationale>Spring Security convention for authorities (ROLE_ADMIN, ROLE_USER)</rationale>
      <validation>new SimpleGrantedAuthority("ROLE_" + role.toUpperCase())</validation>
    </constraint>

    <constraint id="JWT-3" type="JWT" priority="HIGH">
      <rule>Principal username MUST be extracted from 'preferred_username' claim</rule>
      <rationale>Keycloak uses 'preferred_username' for display name (e.g., admin@bank.com)</rationale>
      <validation>String username = jwt.getClaimAsString("preferred_username")</validation>
    </constraint>

    <constraint id="JWT-4" type="JWT" priority="MEDIUM">
      <rule>JWT without 'realm_access' claim MUST gracefully degrade (empty authorities)</rule>
      <rationale>Prevent NullPointerException, return empty list instead</rationale>
      <validation>if (realmAccess == null) return Collections.emptyList()</validation>
    </constraint>

    <!-- Configuration Constraints -->
    <constraint id="CFG-1" type="CONFIGURATION" priority="CRITICAL">
      <rule>Keycloak issuer-uri MUST be configured per environment (local/uat/prod)</rule>
      <rationale>Different Keycloak instances for each environment</rationale>
      <validation>application-{local/uat/prod}.yml with different issuer-uri values</validation>
    </constraint>

    <constraint id="CFG-2" type="CONFIGURATION" priority="HIGH">
      <rule>JWKS endpoint MUST be accessible at startup (fail-fast if unreachable)</rule>
      <rationale>Application should not start if Keycloak is unreachable</rationale>
      <validation>Spring Security fetches JWKS at startup, throws exception if fails</validation>
    </constraint>

    <!-- Testing Constraints -->
    <constraint id="TEST-1" type="TESTING" priority="CRITICAL">
      <rule>Integration tests MUST use Spring Security Test's jwt() request post processor</rule>
      <rationale>MockMvc with jwt() correctly simulates authenticated requests</rationale>
      <validation>.with(jwt().authorities(new SimpleGrantedAuthority("ROLE_USER")))</validation>
    </constraint>

    <constraint id="TEST-2" type="TESTING" priority="HIGH">
      <rule>Integration tests MUST validate HTTP status codes (200, 401, 403)</rule>
      <rationale>Verify security rules are correctly enforced</rationale>
      <validation>.andExpect(status().isOk()) / .andExpect(status().isUnauthorized())</validation>
    </constraint>

    <!-- Documentation Constraints -->
    <constraint id="DOC-1" type="DOCUMENTATION" priority="HIGH">
      <rule>README.md MUST include Keycloak setup instructions and get-token.sh usage</rule>
      <rationale>Developers need clear instructions to obtain JWT tokens for testing</rationale>
      <validation>README.md Security section with curl examples</validation>
    </constraint>

  </constraints>

  <!--
    ============================================================================
    INTERFACES
    ============================================================================
    Key interfaces and contracts.
  -->
  <interfaces>
    
    <!-- Interface 1: OAuth2 Resource Server JWT Validation -->
    <interface id="oauth2-resource-server-jwt">
      <name>OAuth2 Resource Server JWT Validation Protocol</name>
      <type>Spring Security Protocol</type>
      <description>
        Spring Security OAuth2 Resource Server validates JWT tokens by:
        1. Extracting Bearer token from Authorization header
        2. Fetching RSA public key from Keycloak JWKS endpoint
        3. Validating JWT signature (RSA 256)
        4. Validating expiration (exp claim must be &gt; now())
        5. Validating issuer (iss claim must match issuer-uri)
        6. Converting JWT to Authentication token via JwtAuthenticationConverter
      </description>
      <methods>
        <method>
          <name>JwtDecoder.decode(String token)</name>
          <input>JWT token string</input>
          <output>Jwt object (claims, headers)</output>
          <exception>JwtException if signature invalid, expired, or issuer mismatch</exception>
        </method>
        <method>
          <name>JwtAuthenticationConverter.convert(Jwt jwt)</name>
          <input>Jwt object</input>
          <output>AbstractAuthenticationToken (with authorities, principal)</output>
        </method>
      </methods>
    </interface>

    <!-- Interface 2: Keycloak JWKS Endpoint -->
    <interface id="keycloak-jwks-endpoint">
      <name>Keycloak JWKS Endpoint Protocol</name>
      <type>HTTP REST API</type>
      <description>
        Keycloak exposes RSA public keys via JWKS endpoint for JWT signature validation.
        Spring Security fetches keys at startup and caches for 5 minutes.
      </description>
      <endpoint>
        <url>http://localhost:8080/realms/signature-router/protocol/openid-connect/certs</url>
        <method>GET</method>
        <response-format>JSON (JWK Set)</response-format>
        <example-response>
{
  "keys": [
    {
      "kid": "FJ86GcF3jTbNLOco4NvZkUCIUmfYCqoqtOQeMfbhNlE",
      "kty": "RSA",
      "alg": "RS256",
      "use": "sig",
      "n": "xGOr-H7A...",
      "e": "AQAB"
    }
  ]
}
        </example-response>
      </endpoint>
    </interface>

    <!-- Interface 3: JWT Claims Structure -->
    <interface id="jwt-claims-structure">
      <name>Keycloak JWT Claims Structure</name>
      <type>Data Contract</type>
      <description>JWT payload claims from Keycloak with realm_access roles</description>
      <claims>
        <claim name="iss" type="string" required="true">Issuer URI (e.g., http://localhost:8080/realms/signature-router)</claim>
        <claim name="sub" type="string" required="true">Subject (user ID UUID)</claim>
        <claim name="exp" type="number" required="true">Expiration time (Unix timestamp)</claim>
        <claim name="iat" type="number" required="true">Issued at time (Unix timestamp)</claim>
        <claim name="preferred_username" type="string" required="true">Username (e.g., admin@bank.com)</claim>
        <claim name="email" type="string" required="false">User email</claim>
        <claim name="realm_access" type="object" required="false">
          <nested-claim name="roles" type="array&lt;string&gt;">List of realm roles (e.g., ["admin", "user"])</nested-claim>
        </claim>
      </claims>
    </interface>

    <!-- Interface 4: Spring Security SecurityContext -->
    <interface id="spring-security-context">
      <name>Spring Security SecurityContext</name>
      <type>Spring Framework API</type>
      <description>Controllers access authenticated user via SecurityContextHolder</description>
      <usage-example>
// In controller:
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
String username = auth.getName(); // "admin@bank.com"
Collection&lt;? extends GrantedAuthority&gt; authorities = auth.getAuthorities(); // [ROLE_ADMIN, ROLE_USER]
      </usage-example>
    </interface>

  </interfaces>

  <!--
    ============================================================================
    TEST IDEAS
    ============================================================================
    Test scenarios mapped to Acceptance Criteria.
  -->
  <test-ideas>
    
    <!-- Unit Tests: KeycloakJwtAuthenticationConverter -->
    <test id="unit-1" type="UNIT" ac="AC4">
      <name>testConvert_WithAdminRole_MapsToRoleAdmin</name>
      <description>Given JWT with realm_access.roles: ["admin"], When convert(), Then authorities contain ROLE_ADMIN</description>
      <expected-result>authorities.size() == 1, authorities contains "ROLE_ADMIN"</expected-result>
    </test>

    <test id="unit-2" type="UNIT" ac="AC4">
      <name>testConvert_WithMultipleRoles_MapsAllRoles</name>
      <description>Given JWT with realm_access.roles: ["admin", "user", "auditor"], When convert(), Then authorities contain ROLE_ADMIN, ROLE_USER, ROLE_AUDITOR</description>
      <expected-result>authorities.size() == 3, all roles mapped with ROLE_ prefix and uppercased</expected-result>
    </test>

    <test id="unit-3" type="UNIT" ac="AC4">
      <name>testConvert_WithoutRealmAccess_ReturnsEmptyAuthorities</name>
      <description>Given JWT without realm_access claim, When convert(), Then authorities is empty list (graceful degradation)</description>
      <expected-result>authorities.isEmpty() == true, NO NullPointerException</expected-result>
    </test>

    <test id="unit-4" type="UNIT" ac="AC4">
      <name>testConvert_WithNullRoles_ReturnsEmptyAuthorities</name>
      <description>Given JWT with realm_access but null roles, When convert(), Then authorities is empty list</description>
      <expected-result>authorities.isEmpty() == true</expected-result>
    </test>

    <!-- Integration Tests: OAuth2 Security -->
    <test id="integration-1" type="INTEGRATION" ac="AC5">
      <name>testApiWithValidJwt_Returns200</name>
      <description>Given valid JWT with ROLE_USER, When GET /api/v1/signatures, Then HTTP 200</description>
      <expected-result>status().isOk(), NO WWW-Authenticate header</expected-result>
    </test>

    <test id="integration-2" type="INTEGRATION" ac="AC6">
      <name>testApiWithoutJwt_Returns401</name>
      <description>Given NO JWT token, When GET /api/v1/signatures, Then HTTP 401 Unauthorized</description>
      <expected-result>status().isUnauthorized(), WWW-Authenticate header present</expected-result>
    </test>

    <test id="integration-3" type="INTEGRATION" ac="AC7">
      <name>testApiWithExpiredJwt_Returns401</name>
      <description>Given expired JWT (exp claim in past), When GET /api/v1/signatures, Then HTTP 401</description>
      <expected-result>status().isUnauthorized(), log message "JWT expired"</expected-result>
    </test>

    <test id="integration-4" type="INTEGRATION" ac="AC8">
      <name>testApiWithInvalidSignature_Returns401</name>
      <description>Given tampered JWT (invalid signature), When GET /api/v1/signatures, Then HTTP 401</description>
      <expected-result>status().isUnauthorized(), log message "Invalid JWT signature"</expected-result>
    </test>

    <test id="integration-5" type="INTEGRATION" ac="AC9">
      <name>testSwaggerUiWithoutJwt_Returns200</name>
      <description>Given NO JWT token, When GET /swagger-ui/index.html, Then HTTP 200 (public endpoint)</description>
      <expected-result>status().isOk(), NO authentication required</expected-result>
    </test>

    <test id="integration-6" type="INTEGRATION" ac="AC9">
      <name>testActuatorHealthWithoutJwt_Returns200</name>
      <description>Given NO JWT token, When GET /actuator/health, Then HTTP 200 with status: UP</description>
      <expected-result>status().isOk(), jsonPath("$.status").value("UP")</expected-result>
    </test>

    <test id="integration-7" type="INTEGRATION" ac="AC9">
      <name>testActuatorPrometheusWithoutJwt_Returns200</name>
      <description>Given NO JWT token, When GET /actuator/prometheus, Then HTTP 200 with metrics</description>
      <expected-result>status().isOk(), content contains "jvm_memory_used_bytes"</expected-result>
    </test>

    <!-- Manual Tests -->
    <test id="manual-1" type="MANUAL" ac="AC10">
      <name>testApplicationStartupWithKeycloak</name>
      <description>Start application with Keycloak running, verify no errors in logs</description>
      <steps>
        <step>1. docker-compose up -d keycloak</step>
        <step>2. mvn spring-boot:run -Dspring-boot.run.profiles=local</step>
        <step>3. Check logs for "JWT authentication filter initialized"</step>
        <step>4. Check logs for NO errors: "Failed to retrieve JWK Set"</step>
      </steps>
      <expected-result>Application starts successfully in &lt; 10 seconds, NO errors</expected-result>
    </test>

    <test id="manual-2" type="MANUAL" ac="AC11">
      <name>testKeycloakJwksEndpointAccessible</name>
      <description>Verify Keycloak JWKS endpoint returns RSA public keys</description>
      <steps>
        <step>1. curl http://localhost:8080/realms/signature-router/protocol/openid-connect/certs</step>
        <step>2. Verify JSON response contains "keys" array</step>
        <step>3. Verify first key has "kty": "RSA", "alg": "RS256"</step>
      </steps>
      <expected-result>JWKS endpoint returns valid RSA keys</expected-result>
    </test>

    <test id="manual-3" type="MANUAL" ac="AC12">
      <name>testGetTokenScriptWorks</name>
      <description>Verify get-token.sh script returns valid JWT token</description>
      <steps>
        <step>1. chmod +x keycloak/get-token.sh</step>
        <step>2. ./keycloak/get-token.sh admin@bank.com admin123</step>
        <step>3. Verify "✅ JWT Token obtained successfully!" message</step>
        <step>4. Copy token and use: curl -H "Authorization: Bearer $TOKEN" http://localhost:8080/api/v1/signatures</step>
      </steps>
      <expected-result>Script returns valid JWT token, API call with token returns HTTP 200</expected-result>
    </test>

  </test-ideas>

  <!--
    ============================================================================
    IMPLEMENTATION NOTES
    ============================================================================
    Critical implementation guidance and priorities.
  -->
  <implementation-notes>
    
    <priority level="CRITICAL">
      <note>Story 8.1 is BLOCKER for all other Epic 8 stories (8.2 RBAC depends on JWT roles extraction)</note>
      <note>OAuth2 Resource Server MUST be operational before Story 8.2 (RBAC) can start</note>
    </priority>

    <priority level="CRITICAL">
      <note>KeycloakJwtAuthenticationConverter MUST handle graceful degradation (null realm_access → empty authorities)</note>
      <note>NEVER throw NullPointerException if JWT claims are missing (return empty list instead)</note>
    </priority>

    <priority level="HIGH">
      <note>SecurityFilterChain order matters: permitAll() rules MUST come BEFORE authenticated() rules</note>
      <note>Public endpoints (/swagger-ui/**, /actuator/**) MUST be defined BEFORE protected endpoints (/api/v1/**)</note>
    </priority>

    <priority level="HIGH">
      <note>Multi-environment configuration is MANDATORY (local/uat/prod have different Keycloak instances)</note>
      <note>application-local.yml: localhost:8080, application-uat.yml: keycloak-uat.bank.com, application-prod.yml: keycloak.bank.com</note>
    </priority>

    <priority level="MEDIUM">
      <note>get-token.sh script requires 'jq' tool installed (JSON parsing): sudo apt install jq</note>
      <note>Windows users: Use Git Bash or WSL to run get-token.sh (PowerShell alternative: get-token.ps1 TODO)</note>
    </priority>

    <priority level="MEDIUM">
      <note>JWKS caching: Spring Security caches RSA public keys for 5 minutes (reduces load on Keycloak)</note>
      <note>If Keycloak rotates keys, Spring Security auto-fetches new keys after cache expires</note>
    </priority>

    <priority level="LOW">
      <note>Logging: Set org.springframework.security: DEBUG in application-local.yml for troubleshooting JWT validation</note>
      <note>Logs show: JWT claims extraction, authorities mapping, authentication success/failure</note>
    </priority>

  </implementation-notes>

  <!--
    ============================================================================
    DEFINITION OF DONE
    ============================================================================
  -->
  <definition-of-done>
    <checklist>
      <item priority="CRITICAL" checked="false">KeycloakJwtAuthenticationConverter.java created with roles extraction from realm_access.roles</item>
      <item priority="CRITICAL" checked="false">SecurityConfig.java updated with .oauth2ResourceServer(oauth2 -> oauth2.jwt(...))</item>
      <item priority="CRITICAL" checked="false">application.yml configured with spring.security.oauth2.resourceserver.jwt (issuer-uri, jwk-set-uri)</item>
      <item priority="CRITICAL" checked="false">application-local.yml configured with Keycloak localhost URI</item>
      <item priority="HIGH" checked="false">application-uat.yml configured with Keycloak UAT URI</item>
      <item priority="HIGH" checked="false">application-prod.yml configured with Keycloak Prod URI</item>
      <item priority="HIGH" checked="false">get-token.sh helper script created and tested</item>
      <item priority="CRITICAL" checked="false">OAuth2SecurityIntegrationTest.java created with 7 integration tests (all passing)</item>
      <item priority="HIGH" checked="false">KeycloakJwtAuthenticationConverterTest.java created with 4 unit tests (all passing)</item>
      <item priority="CRITICAL" checked="false">mvn test → BUILD SUCCESS (all tests passing, NO regressions)</item>
      <item priority="HIGH" checked="false">Application starts successfully with Keycloak running (NO errors in logs)</item>
      <item priority="MEDIUM" checked="false">get-token.sh returns valid JWT token (tested manually with curl)</item>
      <item priority="MEDIUM" checked="false">Valid JWT → HTTP 200 (tested with curl)</item>
      <item priority="MEDIUM" checked="false">Missing JWT → HTTP 401 (tested with curl)</item>
      <item priority="MEDIUM" checked="false">Public endpoints accessible without JWT (Swagger UI, Actuator health)</item>
      <item priority="HIGH" checked="false">README.md updated with Security & Authentication section (Keycloak setup, get-token.sh usage)</item>
      <item priority="MEDIUM" checked="false">CHANGELOG.md updated with Story 8.1 entry (detailed change list)</item>
      <item priority="LOW" checked="false">docs/security/OAUTH2.md created with OAuth2 configuration guide</item>
      <item priority="HIGH" checked="false">Code review completed (senior developer approval)</item>
      <item priority="MEDIUM" checked="false">No Sonar violations (security, bugs, code smells)</item>
      <item priority="MEDIUM" checked="false">JavaDoc complete for KeycloakJwtAuthenticationConverter (public methods)</item>
    </checklist>
  </definition-of-done>

</story-context>
