<?xml version="1.0" encoding="UTF-8"?>
<story-context id="bmad/bmm/workflows/4-implementation/story-context/1-7-rest-api-foundation-security" v="1.0">
  <metadata>
    <epicId>epic-1</epicId>
    <storyId>1.7</storyId>
    <title>REST API Foundation & Security</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-27</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-7-rest-api-foundation-security.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Developer</asA>
    <iWant>REST API base con OpenAPI, security (OAuth2 JWT), y exception handling</iWant>
    <soThat>Puedo exponer endpoints seguros documentados automáticamente</soThat>
    <tasks>
      - Task 1: Add Maven Dependencies (springdoc-openapi, spring-security, oauth2-resource-server)
      - Task 2: Configure OpenAPI (Springdoc) - OpenApiConfig.java
      - Task 3: Create ErrorResponse DTO (standard error format)
      - Task 4: Create Global Exception Handler (@RestControllerAdvice)
      - Task 5: Create JWT Authentication Converter (roles extraction)
      - Task 6: Create Security Configuration (SecurityFilterChain with JWT + CORS)
      - Task 7: Configure OAuth2 Resource Server (application.yml)
      - Task 8: Configure Actuator Health Endpoint
      - Task 9: Create NotFoundException (domain exception)
      - Task 10: Create Integration Tests (MockMvc security validation)
      - Task 11: Create Example REST Controller (HealthController smoke test)
      - Task 12: Update Documentation (README REST API section, CHANGELOG)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1" title="OpenAPI 3.1 Documentation (Springdoc)">
      <given>Spring Boot application running</given>
      <when>Accedo a /swagger-ui.html</when>
      <then>
        - Swagger UI interactiva visible
        - Endpoints documentados automáticamente
        - Request/Response schemas generados
        - Try-it-out funciona correctamente
        - Springdoc OpenAPI Starter WebMVC UI 2.x dependency agregada
        - application.yml configurado: title "Signature Router API", version "0.1.0"
        - API versioned: base path /api/v1/
      </then>
    </criterion>

    <criterion id="AC2" title="OAuth2 Resource Server (JWT)">
      <given>OAuth2 JWT authentication requerido</given>
      <when>Cliente envía request con JWT token válido en header Authorization: Bearer {token}</when>
      <then>
        - Token validado contra RSA public key
        - Claims extraídos (subject, roles, expiration)
        - Request procesado si token válido
        - Si token inválido: HTTP 401 Unauthorized
        - spring-boot-starter-oauth2-resource-server dependency agregada
        - application.yml con spring.security.oauth2.resourceserver.jwt.issuer-uri configurado
      </then>
    </criterion>

    <criterion id="AC3" title="Security Configuration (SecurityFilterChain)">
      <given>Security policies defined</given>
      <when>Configuro SecurityConfig.java</when>
      <then>
        - SecurityFilterChain bean creado
        - Permitir sin auth: /swagger-ui/**, /v3/api-docs/**, /actuator/health
        - Requerir auth: /api/v1/**
        - CORS habilitado (development: localhost:3000)
        - CSRF deshabilitado (stateless JWT)
        - Session management: STATELESS
        - Role-based: /api/v1/admin/** requiere ADMIN
      </then>
    </criterion>

    <criterion id="AC4" title="JWT Roles Extraction (Custom Converter)">
      <given>JWT token con roles en custom claim</given>
      <when>Creo JwtAuthenticationConverter</when>
      <then>
        - Roles extraídos de JWT claim path configurado
        - Convertidos a GrantedAuthority con prefix ROLE_
        - Available en @PreAuthorize("hasRole('ADMIN')")
        - Roles soportados: ROLE_ADMIN, ROLE_AUDITOR, ROLE_SUPPORT, ROLE_USER
      </then>
    </criterion>

    <criterion id="AC5" title="Global Exception Handler">
      <given>Exceptions pueden ocurrir en controllers</given>
      <when>Creo GlobalExceptionHandler.java</when>
      <then>
        - @RestControllerAdvice annotation
        - DomainException → HTTP 422
        - NotFoundException → HTTP 404
        - MethodArgumentNotValidException → HTTP 400 with field errors
        - AccessDeniedException → HTTP 403
        - Exception → HTTP 500 (NO stack trace in response)
        - Todos responses incluyen: timestamp, traceId, path
      </then>
    </criterion>

    <criterion id="AC6" title="ErrorResponse DTO (Standard Format)">
      <given>Consistent error response format needed</given>
      <when>Creo ErrorResponse.java DTO</when>
      <then>
        - Fields: code, message, details (Map), timestamp, traceId, path
        - @JsonInclude(NON_NULL) para details
        - Builder pattern con Lombok
      </then>
    </criterion>

    <criterion id="AC7" title="Health Check Endpoint (Actuator)">
      <given>Monitoring requires health status</given>
      <when>Accedo a /actuator/health</when>
      <then>
        - HTTP 200 OK si todos componentes UP
        - HTTP 503 si algún componente DOWN
        - Response: { "status": "UP", "components": { "db": "UP", "vault": "UP" } }
        - management.endpoints.web.exposure.include=health,info
        - management.endpoint.health.show-details=always (development)
      </then>
    </criterion>

    <criterion id="AC8" title="CORS Configuration (Development)">
      <given>Frontend development en localhost:3000</given>
      <when>Configuro CORS en SecurityConfig.java</when>
      <then>
        - Origins: http://localhost:3000, http://localhost:4200
        - Methods: GET, POST, PUT, DELETE, PATCH, OPTIONS
        - Headers: Authorization, Content-Type, X-Request-ID
        - Credentials: true
        - Max age: 3600
        - Production: origins restrictivos (application-prod.yml)
      </then>
    </criterion>

    <criterion id="AC9" title="Request/Response Logging (Interceptor)">
      <given>Debugging requiere request/response logs</given>
      <when>Creo LoggingInterceptor.java (optional)</when>
      <then>
        - Log request: method, URI, headers (excluir Authorization), body
        - Log response: status, headers, body
        - Log duration: processing time
        - Log level: DEBUG para bodies, INFO para summary
        - Production: INFO level (no bodies)
      </then>
    </criterion>

    <criterion id="AC10" title="API Versioning Strategy">
      <given>API evolution requires versioning</given>
      <when>Defino base path /api/v1/</when>
      <then>
        - Controllers: @RequestMapping("/api/v1/signature")
        - OpenAPI docs: version "v1"
        - Response headers: X-API-Version: 1.0
        - Future: /api/v2/ para breaking changes
      </then>
    </criterion>

    <criterion id="AC11" title="Integration Test (MockMvc Security)">
      <given>Security configuration debe ser testeada</given>
      <when>Creo SecurityConfigurationIntegrationTest.java</when>
      <then>
        - testSwaggerUiAccessibleWithoutAuth() - Swagger accesible sin JWT
        - testApiRequiresAuthentication() - /api/v1/** retorna 401 sin JWT
        - testApiAccessibleWithValidJwt() - /api/v1/** retorna 200 con JWT válido
        - testAdminEndpointRequiresAdminRole() - /api/v1/admin/** retorna 403 sin ADMIN
        - testHealthEndpointAccessibleWithoutAuth() - /actuator/health accesible sin JWT
        - @SpringBootTest o @WebMvcTest con security
        - Mock JWT tokens con custom roles
      </then>
    </criterion>

    <criterion id="AC12" title="Documentation & Examples">
      <given>Story 1.7 implementado</given>
      <when>Actualizo documentación</when>
      <then>
        - README.md con sección "REST API & Security"
        - OpenAPI access (/swagger-ui.html)
        - JWT authentication flow
        - RBAC (role-based access control)
        - Error response format
        - CHANGELOG.md con Story 1.7 entry
        - JavaDoc en SecurityConfig, GlobalExceptionHandler, JwtAuthenticationConverter
      </then>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact id="architecture-security" path="docs/architecture/07-observability-security.md">
        <section name="Security Strategy" lines="110-250">
          <oauth2_flow>OAuth2 Resource Server with JWT validation (RSA public key)</oauth2_flow>
          <jwt_claims>subject (sub), roles (custom claim path), expiration (exp)</jwt_claims>
          <security_policies>Public: Swagger UI, Actuator health; Authenticated: /api/v1/**; Admin: /api/v1/admin/**</security_policies>
          <cors_strategy>Development: localhost origins; Production: restrictive</cors_strategy>
        </section>
        <section name="Logging Strategy" lines="28-110">
          <structured_logging>JSON format with Logstash encoder</structured_logging>
          <mdc_context>traceId, spanId, signatureId, customerId, provider, channelType</mdc_context>
          <log_levels>INFO for production, DEBUG for development</log_levels>
        </section>
      </artifact>

      <artifact id="tech-spec-epic-1" path="docs/sprint-artifacts/tech-spec-epic-1.md">
        <section name="Security Requirements" lines="150-200">
          <authentication>OAuth2 JWT with RSA public key validation</authentication>
          <authorization>Role-based: ADMIN, AUDITOR, SUPPORT, USER</authorization>
          <session_management>Stateless (no server sessions)</session_management>
        </section>
      </artifact>

      <artifact id="hexagonal-architecture" path="docs/architecture/02-hexagonal-structure.md">
        <section name="Inbound Adapters (REST)" lines="150-200">
          <purpose>REST controllers implement inbound ports (use case interfaces)</purpose>
          <pattern>Controller → Use Case (application layer) → Domain</pattern>
          <location>infrastructure/adapter/inbound/rest/controller/</location>
        </section>
      </artifact>

      <artifact id="epics" path="docs/epics.md">
        <section name="Story 1.7 Definition" lines="347-382">
          <description>REST API base con OpenAPI, security (OAuth2 JWT), exception handling</description>
          <prerequisites>Story 1.1 (Spring Boot base)</prerequisites>
        </section>
      </artifact>
    </docs>

    <code>
      <artifact id="openapi-config-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * OpenAPI 3.1 configuration for Springdoc.
 * 
 * <p>Provides interactive Swagger UI at /swagger-ui.html with automatic
 * request/response schema generation.</p>
 * 
 * @since Story 1.7
 */
@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Signature Router API")
                .version("0.1.0")
                .description("Banking-grade Signature Router & Management System with DDD + Hexagonal Architecture")
                .contact(new Contact()
                    .name("Bank Signature Team")
                    .email("signature-team@bank.com"))
                .license(new License()
                    .name("Proprietary")
                    .url("https://bank.com/license")))
            .addServersItem(new Server()
                .url("http://localhost:8080")
                .description("Local development"))
            .addServersItem(new Server()
                .url("https://api-uat.signature-router.bank.com")
                .description("UAT environment"))
            .addServersItem(new Server()
                .url("https://api.signature-router.bank.com")
                .description("Production"))
            .addSecurityItem(new SecurityRequirement().addList("Bearer Authentication"))
            .components(new io.swagger.v3.oas.models.Components()
                .addSecuritySchemes("Bearer Authentication", new SecurityScheme()
                    .type(SecurityScheme.Type.HTTP)
                    .scheme("bearer")
                    .bearerFormat("JWT")
                    .description("JWT token obtained from OAuth2 authorization server")));
    }
}
        ]]></content>
        <critical_notes>
          - OpenAPI 3.1 spec con security scheme: Bearer JWT
          - Servers configurados: local, UAT, production
          - Security requirement aplicado globalmente
        </critical_notes>
      </artifact>

      <artifact id="error-response-dto-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.inbound.rest.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Builder;
import lombok.Value;

import java.util.Map;

/**
 * Standard error response DTO for consistent error handling across all REST endpoints.
 * 
 * <p><b>Usage Example:</b></p>
 * <pre>{@code
 * {
 *   "code": "FALLBACK_EXHAUSTED",
 *   "message": "All fallback channels have been exhausted",
 *   "details": { "requestId": "abc-123", "channelsAttempted": ["SMS", "PUSH"] },
 *   "timestamp": "2025-11-27T10:30:00.000Z",
 *   "traceId": "64f3a2b1c9e8d7f6",
 *   "path": "/api/v1/signature/abc-123/complete"
 * }
 * }</pre>
 * 
 * @since Story 1.7
 */
@Value
@Builder
public class ErrorResponse {
    
    /**
     * Machine-readable error code (e.g., "VALIDATION_ERROR", "FALLBACK_EXHAUSTED").
     */
    String code;
    
    /**
     * Human-readable error message.
     */
    String message;
    
    /**
     * Additional error details (field validation errors, etc.). Omitted if null.
     */
    @JsonInclude(JsonInclude.Include.NON_NULL)
    Map<String, Object> details;
    
    /**
     * ISO 8601 timestamp when error occurred.
     */
    String timestamp;
    
    /**
     * Distributed tracing correlation ID (for log correlation).
     */
    String traceId;
    
    /**
     * Request path that caused the error.
     */
    String path;
}
        ]]></content>
      </artifact>

      <artifact id="global-exception-handler-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.inbound.rest.exception;

import com.bank.signature.domain.exception.DomainException;
import com.bank.signature.domain.exception.NotFoundException;
import com.bank.signature.infrastructure.adapter.inbound.rest.dto.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for consistent error responses across all REST endpoints.
 * 
 * <p>Maps exceptions to HTTP status codes and ErrorResponse DTOs with trace correlation.</p>
 * 
 * @since Story 1.7
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * Handle domain-specific exceptions (business logic errors).
     * 
     * @param ex Domain exception
     * @param request HTTP servlet request
     * @return ErrorResponse with HTTP 422
     */
    @ExceptionHandler(DomainException.class)
    @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
    public ErrorResponse handleDomainException(DomainException ex, HttpServletRequest request) {
        log.warn("Domain exception: {} - {}", ex.getErrorCode(), ex.getMessage());
        return buildErrorResponse(ex.getErrorCode(), ex.getMessage(), null, request);
    }
    
    /**
     * Handle entity not found exceptions.
     * 
     * @param ex NotFoundException
     * @param request HTTP servlet request
     * @return ErrorResponse with HTTP 404
     */
    @ExceptionHandler(NotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        log.info("Entity not found: {}", ex.getMessage());
        return buildErrorResponse("NOT_FOUND", ex.getMessage(), null, request);
    }
    
    /**
     * Handle validation exceptions (Bean Validation).
     * 
     * @param ex MethodArgumentNotValidException
     * @param request HTTP servlet request
     * @return ErrorResponse with HTTP 400 and field errors
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleValidationException(MethodArgumentNotValidException ex, HttpServletRequest request) {
        Map<String, Object> fieldErrors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            fieldErrors.put(error.getField(), error.getDefaultMessage())
        );
        
        log.warn("Validation failed: {}", fieldErrors);
        return buildErrorResponse("VALIDATION_ERROR", "Invalid input", fieldErrors, request);
    }
    
    /**
     * Handle authorization failures (Spring Security).
     * 
     * @param ex AccessDeniedException
     * @param request HTTP servlet request
     * @return ErrorResponse with HTTP 403
     */
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public ErrorResponse handleAccessDeniedException(AccessDeniedException ex, HttpServletRequest request) {
        log.warn("Access denied for path: {} - {}", request.getRequestURI(), ex.getMessage());
        return buildErrorResponse("FORBIDDEN", "Access denied", null, request);
    }
    
    /**
     * Handle unexpected exceptions (fallback).
     * 
     * @param ex Generic exception
     * @param request HTTP servlet request
     * @return ErrorResponse with HTTP 500 (NO stack trace)
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGenericException(Exception ex, HttpServletRequest request) {
        log.error("Unexpected error: ", ex); // Full stack trace in logs
        return buildErrorResponse("INTERNAL_ERROR", "An unexpected error occurred", null, request);
    }
    
    /**
     * Build standard ErrorResponse with trace correlation.
     */
    private ErrorResponse buildErrorResponse(String code, String message, Map<String, Object> details, HttpServletRequest request) {
        return ErrorResponse.builder()
            .code(code)
            .message(message)
            .details(details)
            .timestamp(Instant.now().toString())
            .traceId(MDC.get("traceId") != null ? MDC.get("traceId") : "NO_TRACE")
            .path(request.getRequestURI())
            .build();
    }
}
        ]]></content>
      </artifact>

      <artifact id="jwt-authentication-converter-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.config.security;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Custom JWT authentication converter for extracting roles from JWT claims.
 * 
 * <p>Supports configurable claim paths (e.g., "realm_access.roles" for Keycloak).</p>
 * 
 * @since Story 1.7
 */
@Component
public class JwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    
    private static final String ROLE_PREFIX = "ROLE_";
    private static final String ROLES_CLAIM = "roles"; // Simple JWT
    // For Keycloak: "realm_access.roles"
    
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection<GrantedAuthority> authorities = extractRoles(jwt);
        return new JwtAuthenticationToken(jwt, authorities);
    }
    
    /**
     * Extract roles from JWT claims and convert to Spring Security authorities.
     * 
     * @param jwt JWT token
     * @return Collection of GrantedAuthority with ROLE_ prefix
     */
    private Collection<GrantedAuthority> extractRoles(Jwt jwt) {
        // Simple JWT with direct "roles" claim
        List<String> roles = jwt.getClaimAsStringList(ROLES_CLAIM);
        
        if (roles == null || roles.isEmpty()) {
            return List.of();
        }
        
        return roles.stream()
            .map(role -> new SimpleGrantedAuthority(ROLE_PREFIX + role.toUpperCase()))
            .collect(Collectors.toList());
    }
}
        ]]></content>
        <critical_notes>
          - ROLE_ prefix mandatory for Spring Security @PreAuthorize("hasRole('ADMIN')")
          - Configurable claim path (ROLES_CLAIM constant)
          - For Keycloak: need to extract from nested claim "realm_access.roles"
        </critical_notes>
      </artifact>

      <artifact id="security-config-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.config;

import com.bank.signature.infrastructure.config.security.JwtAuthenticationConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

/**
 * Security configuration for OAuth2 Resource Server with JWT validation.
 * 
 * <p><b>Security Policies:</b></p>
 * <ul>
 *   <li>Public (no auth): /swagger-ui/**, /v3/api-docs/**, /actuator/health</li>
 *   <li>Authenticated (any role): /api/v1/**</li>
 *   <li>Admin only: /api/v1/admin/**</li>
 * </ul>
 * 
 * <p><b>Session Management:</b> Stateless (no server sessions)</p>
 * <p><b>CSRF:</b> Disabled (stateless JWT)</p>
 * 
 * @since Story 1.7
 */
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    private final JwtAuthenticationConverter jwtAuthenticationConverter;
    
    public SecurityConfig(JwtAuthenticationConverter jwtAuthenticationConverter) {
        this.jwtAuthenticationConverter = jwtAuthenticationConverter;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                // Public endpoints (no authentication)
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .requestMatchers("/actuator/health", "/actuator/info").permitAll()
                .requestMatchers("/api/v1/health").permitAll() // Example endpoint
                
                // Admin-only endpoints
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                
                // Support or Admin for routing rules
                .requestMatchers("/api/v1/routing/**").hasAnyRole("ADMIN", "SUPPORT")
                
                // All other /api/v1/** endpoints require authentication
                .requestMatchers("/api/v1/**").authenticated()
                
                // Deny all other requests
                .anyRequest().denyAll()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter))
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .csrf(csrf -> csrf.disable()) // Stateless JWT, no CSRF needed
            .cors(cors -> cors.configurationSource(corsConfigurationSource()));
        
        return http.build();
    }
    
    /**
     * CORS configuration source.
     * 
     * <p>Development: Allow localhost:3000, localhost:4200</p>
     * <p>Production: Should be configured via application-prod.yml</p>
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // Allowed origins (should be externalized to application.yml)
        configuration.setAllowedOrigins(List.of(
            "http://localhost:3000",  // React dev server
            "http://localhost:4200"   // Angular dev server
        ));
        
        // Allowed HTTP methods
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));
        
        // Allowed headers
        configuration.setAllowedHeaders(List.of("Authorization", "Content-Type", "X-Request-ID"));
        
        // Allow credentials (cookies, auth headers)
        configuration.setAllowCredentials(true);
        
        // Max age (cache preflight response)
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
        ]]></content>
      </artifact>

      <artifact id="not-found-exception-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.domain.exception;

import java.util.UUID;

/**
 * Domain exception thrown when an entity is not found.
 * 
 * <p>Maps to HTTP 404 Not Found via GlobalExceptionHandler.</p>
 * 
 * @since Story 1.7
 */
public class NotFoundException extends DomainException {
    
    private static final String ERROR_CODE = "NOT_FOUND";
    
    /**
     * Constructor for entity not found by ID.
     * 
     * @param entityType Type of entity (e.g., "SignatureRequest")
     * @param id Entity ID
     */
    public NotFoundException(String entityType, UUID id) {
        super(String.format("%s with ID %s not found", entityType, id), ERROR_CODE);
    }
    
    /**
     * Constructor for entity not found by arbitrary criteria.
     * 
     * @param message Custom error message
     */
    public NotFoundException(String message) {
        super(message, ERROR_CODE);
    }
}
        ]]></content>
      </artifact>

      <artifact id="health-controller-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.inbound.rest.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.Instant;
import java.util.Map;

/**
 * Health controller for API smoke testing.
 * 
 * <p>Example REST endpoint demonstrating OpenAPI documentation.</p>
 * 
 * @since Story 1.7
 */
@RestController
@RequestMapping("/api/v1/health")
@Tag(name = "Health", description = "API health check endpoints")
public class HealthController {
    
    /**
     * API health check endpoint.
     * 
     * @return Health status with API version and timestamp
     */
    @GetMapping
    @Operation(summary = "API Health Check", description = "Returns API health status (no authentication required)")
    @ApiResponse(responseCode = "200", description = "API is healthy")
    public ResponseEntity<Map<String, Object>> health() {
        return ResponseEntity.ok(Map.of(
            "status", "UP",
            "apiVersion", "1.0",
            "timestamp", Instant.now().toString()
        ));
    }
}
        ]]></content>
      </artifact>
    </code>

    <dependencies>
      <maven>
        <dependency>
          <groupId>org.springdoc</groupId>
          <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
          <scope>compile</scope>
          <version>2.3.0</version>
          <story>1.7</story>
          <note>OpenAPI 3.1 documentation with Swagger UI</note>
        </dependency>

        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-security</artifactId>
          <scope>compile</scope>
          <version>Managed by Spring Boot</version>
          <story>1.7</story>
          <note>Spring Security framework</note>
        </dependency>

        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
          <scope>compile</scope>
          <version>Managed by Spring Boot</version>
          <story>1.7</story>
          <note>OAuth2 Resource Server with JWT validation</note>
        </dependency>

        <dependency>
          <groupId>org.springframework.security</groupId>
          <artifactId>spring-security-test</artifactId>
          <scope>test</scope>
          <version>Managed by Spring Boot</version>
          <story>1.7</story>
          <note>Security testing utilities (MockMvc with JWT)</note>
        </dependency>
      </maven>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="SEC-1" type="security">
      <rule>JWT tokens DEBEN validarse contra RSA public key (NO shared secret)</rule>
      <validation>OAuth2 Resource Server con issuer-uri o jwk-set-uri configurado</validation>
    </constraint>

    <constraint id="SEC-2" type="security">
      <rule>Session management DEBE ser STATELESS (no server sessions)</rule>
      <validation>SessionCreationPolicy.STATELESS en SecurityFilterChain</validation>
    </constraint>

    <constraint id="SEC-3" type="security">
      <rule>CSRF protection DEBE estar deshabilitado (stateless JWT)</rule>
      <validation>csrf().disable() en SecurityFilterChain</validation>
    </constraint>

    <constraint id="SEC-4" type="security">
      <rule>Roles extraídos de JWT DEBEN tener prefix ROLE_ para Spring Security</rule>
      <validation>JwtAuthenticationConverter agrega ROLE_ prefix</validation>
    </constraint>

    <constraint id="SEC-5" type="security">
      <rule>Swagger UI y Actuator health DEBEN ser públicos (no auth)</rule>
      <validation>.requestMatchers("/swagger-ui/**").permitAll() en SecurityFilterChain</validation>
    </constraint>

    <constraint id="SEC-6" type="security">
      <rule>Admin endpoints (/api/v1/admin/**) DEBEN requerir role ADMIN</rule>
      <validation>.requestMatchers("/api/v1/admin/**").hasRole("ADMIN")</validation>
    </constraint>

    <constraint id="CORS-1" type="configuration">
      <rule>CORS origins DEBEN ser configurables por environment (application.yml)</rule>
      <validation>Development: localhost origins; Production: restrictive origins</validation>
    </constraint>

    <constraint id="CORS-2" type="configuration">
      <rule>CORS DEBE permitir credentials (cookies, auth headers)</rule>
      <validation>setAllowCredentials(true) en CorsConfiguration</validation>
    </constraint>

    <constraint id="ERROR-1" type="implementation">
      <rule>Exception handler DEBE retornar ErrorResponse format consistente</rule>
      <validation>GlobalExceptionHandler retorna ErrorResponse con code, message, details, timestamp, traceId, path</validation>
    </constraint>

    <constraint id="ERROR-2" type="implementation">
      <rule>HTTP 500 responses NO DEBEN exponer stack traces</rule>
      <validation>GlobalExceptionHandler loggea stack trace pero retorna mensaje genérico</validation>
    </constraint>

    <constraint id="ERROR-3" type="implementation">
      <rule>Todas las exceptions DEBEN incluir traceId para log correlation</rule>
      <validation>ErrorResponse.traceId obtiene valor de MDC.get("traceId")</validation>
    </constraint>

    <constraint id="API-1" type="implementation">
      <rule>API base path DEBE ser /api/v1/ para versioning</rule>
      <validation>Controllers usan @RequestMapping("/api/v1/...")</validation>
    </constraint>

    <constraint id="API-2" type="implementation">
      <rule>OpenAPI spec DEBE incluir security scheme (Bearer JWT)</rule>
      <validation>OpenApiConfig define SecurityScheme.Type.HTTP con scheme "bearer"</validation>
    </constraint>

    <constraint id="TEST-1" type="testing">
      <rule>Security policies DEBEN ser validadas con integration tests</rule>
      <validation>SecurityConfigurationIntegrationTest con 5 test methods</validation>
    </constraint>

    <constraint id="TEST-2" type="testing">
      <rule>Integration tests DEBEN usar mock JWT tokens con custom roles</rule>
      <validation>Helper method createMockJwt(String... roles)</validation>
    </constraint>

    <constraint id="DOC-1" type="documentation">
      <rule>JavaDoc MANDATORY en SecurityConfig, GlobalExceptionHandler, JwtAuthenticationConverter</rule>
      <validation>Cada clase tiene JavaDoc con descripción de responsibilities</validation>
    </constraint>
  </constraints>

  <interfaces>
    <interface id="IFC-1" name="OAuth2 Resource Server (Spring Security)">
      <description>JWT validation against issuer's public key</description>
      <contract>
        - Client sends: Authorization: Bearer {JWT_TOKEN}
        - Server validates: signature, expiration, issuer
        - Server extracts: subject, roles (custom claim)
        - Server returns: 401 if invalid, proceeds if valid
      </contract>
      <location>SecurityConfig.java - oauth2ResourceServer().jwt()</location>
    </interface>

    <interface id="IFC-2" name="OpenAPI 3.1 Specification (Springdoc)">
      <description>Automatic API documentation generation</description>
      <contract>
        - Swagger UI: /swagger-ui.html
        - OpenAPI JSON: /v3/api-docs
        - Schemas: Automatic from DTOs
        - Security: Bearer JWT scheme
      </contract>
      <location>OpenApiConfig.java + Controller annotations</location>
    </interface>

    <interface id="IFC-3" name="ErrorResponse Standard Format">
      <description>Consistent error responses across all endpoints</description>
      <contract>
        - Fields: code, message, details, timestamp, traceId, path
        - HTTP status: Mapped by exception type
        - Content-Type: application/json
      </contract>
      <location>ErrorResponse.java DTO + GlobalExceptionHandler.java</location>
    </interface>

    <interface id="IFC-4" name="Actuator Health Endpoint">
      <description>Health check for monitoring systems</description>
      <contract>
        - Endpoint: /actuator/health
        - Response: { "status": "UP"/"DOWN", "components": {...} }
        - HTTP status: 200 if UP, 503 if DOWN
      </contract>
      <location>Spring Boot Actuator (auto-configured)</location>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <standard id="TS-1">Integration tests MANDATORY con MockMvc para security validation</standard>
      <standard id="TS-2">Test Swagger UI accessible sin JWT (public endpoint)</standard>
      <standard id="TS-3">Test /api/v1/** requiere JWT (HTTP 401 sin auth)</standard>
      <standard id="TS-4">Test /api/v1/admin/** requiere role ADMIN (HTTP 403 sin role)</standard>
      <standard id="TS-5">Test /actuator/health accessible sin JWT (public endpoint)</standard>
      <standard id="TS-6">Mock JWT tokens con custom roles para testing</standard>
      <standard id="TS-7">Test coverage > 80% para security config y exception handler</standard>
    </standards>

    <locations>
      <location>src/test/java/com/bank/signature/infrastructure/config/SecurityConfigurationIntegrationTest.java</location>
    </locations>

    <ideas>
      <test id="TEST-1" maps_to="AC1">
        <name>testSwaggerUiAccessibleWithoutAuth</name>
        <approach>GET /swagger-ui.html sin Authorization header, verify HTTP 200 OK, Swagger UI HTML returned</approach>
      </test>

      <test id="TEST-2" maps_to="AC2">
        <name>testApiRequiresAuthentication</name>
        <approach>GET /api/v1/signature sin Authorization header, verify HTTP 401 Unauthorized, ErrorResponse con code "UNAUTHORIZED"</approach>
      </test>

      <test id="TEST-3" maps_to="AC2, AC4">
        <name>testApiAccessibleWithValidJwt</name>
        <approach>GET /api/v1/health con mock JWT (role USER), verify HTTP 200 OK (o 404 si endpoint no existe todavía)</approach>
      </test>

      <test id="TEST-4" maps_to="AC3, AC4">
        <name>testAdminEndpointRequiresAdminRole</name>
        <approach>GET /api/v1/admin/rules con mock JWT (role USER, NO ADMIN), verify HTTP 403 Forbidden, ErrorResponse con code "FORBIDDEN"</approach>
      </test>

      <test id="TEST-5" maps_to="AC7">
        <name>testHealthEndpointAccessibleWithoutAuth</name>
        <approach>GET /actuator/health sin Authorization header, verify HTTP 200 OK, response contains {"status": "UP"}</approach>
      </test>

      <test id="TEST-6" maps_to="AC5">
        <name>testDomainExceptionMapsTo422</name>
        <approach>Trigger DomainException en controller (mock), verify HTTP 422 Unprocessable Entity, ErrorResponse con exception.errorCode</approach>
      </test>

      <test id="TEST-7" maps_to="AC5">
        <name>testNotFoundExceptionMapsTo404</name>
        <approach>Trigger NotFoundException en controller (mock), verify HTTP 404 Not Found, ErrorResponse con code "NOT_FOUND"</approach>
      </test>

      <test id="TEST-8" maps_to="AC5">
        <name>testValidationExceptionMapsTo400WithFieldErrors</name>
        <approach>POST request con invalid body (Bean Validation), verify HTTP 400 Bad Request, ErrorResponse.details contains field errors</approach>
      </test>

      <test id="TEST-9" maps_to="AC11">
        <name>testHealthControllerReturnsApiVersion</name>
        <approach>GET /api/v1/health (public endpoint), verify HTTP 200 OK, response contains {"status": "UP", "apiVersion": "1.0"}</approach>
      </test>
    </ideas>
  </tests>

  <implementation_notes>
    <priority level="CRITICAL">
      <note>OAuth2 Resource Server: DEBE configurarse issuer-uri o jwk-set-uri en application.yml (JWT validation con RSA public key)</note>
      <note>SecurityFilterChain: Swagger UI y Actuator health DEBEN ser públicos (.permitAll()), /api/v1/** DEBE requerir auth</note>
      <note>JWT Roles: DEBE agregar prefix ROLE_ (e.g., "admin" → "ROLE_ADMIN") para Spring Security @PreAuthorize("hasRole('ADMIN')")</note>
      <note>Session Management: DEBE ser STATELESS (SessionCreationPolicy.STATELESS) para JWT stateless</note>
      <note>CSRF: DEBE estar deshabilitado (.csrf().disable()) porque JWT es stateless</note>
    </priority>

    <priority level="HIGH">
      <note>ErrorResponse format: Consistente en todos los endpoints (code, message, details, timestamp, traceId, path)</note>
      <note>HTTP 500: NO exponer stack traces en response (log full stack trace, return generic message)</note>
      <note>TraceId: Incluir en ErrorResponse para log correlation (obtener de MDC.get("traceId"))</note>
      <note>CORS: Configurar origins por environment (localhost para dev, restrictive para prod)</note>
      <note>OpenAPI Security Scheme: Bearer JWT DEBE estar definido en OpenApiConfig</note>
      <note>Integration Tests: 5 test methods MANDATORY (Swagger public, API auth required, admin role, health public, valid JWT)</note>
    </priority>

    <priority level="MEDIUM">
      <note>API Versioning: Base path /api/v1/ para future evolution (/api/v2/ para breaking changes)</note>
      <note>HealthController: Example REST controller para smoke test (OpenAPI documentation demo)</note>
      <note>LoggingInterceptor: Optional pero recomendado para debugging (log request/response con DEBUG level)</note>
      <note>NotFoundException: Domain exception para entity not found (maps to HTTP 404)</note>
    </priority>

    <priority level="LOW">
      <note>Springdoc version: 2.3.0 (latest stable para Spring Boot 3.2.0)</note>
      <note>CORS max age: 3600 seconds (cache preflight response)</note>
      <note>Response headers: Considerar agregar X-API-Version: 1.0 en future</note>
    </priority>
  </implementation_notes>

  <definition_of_done>
    <checklist>
      <item>Code Complete: 3 Maven dependencies agregadas (springdoc-openapi, spring-security, oauth2-resource-server)</item>
      <item>Code Complete: OpenApiConfig.java creado con OpenAPI bean (title, version, security scheme)</item>
      <item>Code Complete: ErrorResponse.java DTO creado (6 fields: code, message, details, timestamp, traceId, path)</item>
      <item>Code Complete: GlobalExceptionHandler.java creado con @RestControllerAdvice (5 exception mappings)</item>
      <item>Code Complete: JwtAuthenticationConverter.java creado (roles extraction con ROLE_ prefix)</item>
      <item>Code Complete: SecurityConfig.java creado con SecurityFilterChain (JWT, CORS, CSRF disable, session STATELESS)</item>
      <item>Code Complete: NotFoundException.java domain exception creado</item>
      <item>Code Complete: HealthController.java example REST controller creado</item>
      <item>Configuration Complete: application.yml con springdoc config (api-docs path, swagger-ui path)</item>
      <item>Configuration Complete: application.yml con security OAuth2 config (issuer-uri o jwk-set-uri)</item>
      <item>Configuration Complete: application.yml con actuator config (health endpoint exposure)</item>
      <item>Configuration Complete: application-local.yml con development config (CORS localhost, health details always)</item>
      <item>Tests Passing: SecurityConfigurationIntegrationTest con 5 test methods (testSwaggerUiAccessibleWithoutAuth, testApiRequiresAuthentication, testApiAccessibleWithValidJwt, testAdminEndpointRequiresAdminRole, testHealthEndpointAccessibleWithoutAuth)</item>
      <item>Tests Passing: Test coverage > 80% para security config y exception handler</item>
      <item>Validation: Swagger UI accessible en /swagger-ui.html (sin JWT)</item>
      <item>Validation: /api/v1/** retorna 401 sin JWT</item>
      <item>Validation: /api/v1/** retorna 200 con JWT válido</item>
      <item>Validation: /api/v1/admin/** retorna 403 sin role ADMIN</item>
      <item>Validation: /actuator/health accessible sin JWT (HTTP 200)</item>
      <item>Documentation Updated: README.md con sección "REST API & Security" (OpenAPI access, JWT flow, RBAC, error format)</item>
      <item>Documentation Updated: CHANGELOG.md con Story 1.7 entry</item>
      <item>Documentation Updated: JavaDoc en SecurityConfig, GlobalExceptionHandler, JwtAuthenticationConverter</item>
      <item>Code Review Approved: Security policies correctas, exception handling consistent, OpenAPI documentation completa</item>
      <item>Story Marked as Done: Todos los 12 ACs verificados</item>
      <item>Story Marked as Done: Sprint status actualizado a done</item>
    </checklist>
  </definition_of_done>
</story-context>
