# ============================================================================
# CURSOR RULES - SIGNATURE ROUTER PROJECT
# ============================================================================

## ğŸ—ï¸ ARQUITECTURA DEL PROYECTO

Este proyecto usa **Arquitectura Hexagonal (Puertos y Adaptadores)** + **DDD (Domain-Driven Design)**.

### Capas:
- **Domain** (`domain/`): LÃ³gica de negocio pura, agregados, value objects, excepciones
- **Application** (`application/`): Casos de uso, DTOs, mappers de aplicaciÃ³n, servicios de aplicaciÃ³n
- **Infrastructure** (`infrastructure/`): Adaptadores (REST, persistence, external services), configuraciÃ³n

---

## ğŸ”´ REGLA CRÃTICA: PROCESO OBLIGATORIO PARA AGREGAR/MODIFICAR CAMPOS

Cuando agregues o modifiques un campo en cualquier entidad/agregado, **DEBES seguir este checklist completo**:

### âœ… CHECKLIST OBLIGATORIO (NO SALTAR NINGÃšN PASO):

1. **Base de datos**
   - [ ] Ejecutar `ALTER TABLE` o crear script de migraciÃ³n Liquibase
   - [ ] Verificar que la columna se creÃ³ correctamente con `SELECT`

2. **Entidad JPA** (`infrastructure/adapter/outbound/persistence/entity/`)
   - [ ] Agregar campo con anotaciÃ³n `@Column`
   - [ ] Verificar tipo de dato correcto (String, TEXT, UUID, etc.)

3. **Domain Model** (`domain/model/aggregate/` o `domain/model/valueobject/`)
   - [ ] Agregar campo al agregado/value object
   - [ ] Actualizar mÃ©todos de negocio (`update()`, constructores, etc.)
   - [ ] Actualizar JavaDoc si es necesario

4. **DTOs** (`application/dto/`)
   - [ ] Agregar campo a `CreateXxxDto`
   - [ ] Agregar campo a `UpdateXxxDto`
   - [ ] Agregar campo a `XxxResponseDto`
   - [ ] Agregar validaciones (`@NotBlank`, `@Size`, etc.) si aplica
   - [ ] Actualizar compact constructors si existen

5. **Mapper de aplicaciÃ³n** (`application/mapper/`)
   - [ ] Actualizar mÃ©todo `toDomain()` para mapear el campo
   - [ ] Actualizar mÃ©todo `toDto()` para mapear el campo
   - [ ] Actualizar mÃ©todo `updateDomain()` si existe

6. **Mapper de infraestructura** (`infrastructure/adapter/outbound/persistence/mapper/`)
   - [ ] Actualizar mÃ©todo `toEntity()` para mapear el campo
   - [ ] Actualizar mÃ©todo `toDomain()` para mapear el campo
   - [ ] Actualizar mÃ©todo `updateEntity()` para mapear el campo

7. **Scripts de datos iniciales** (`scripts/seed-test-data.sql`)
   - [ ] Agregar columna en `INSERT INTO` statements
   - [ ] Proveer valores de ejemplo realistas

8. **Frontend** (si aplica)
   - [ ] Actualizar interfaces TypeScript en `lib/api/types.ts`
   - [ ] Actualizar formularios si es necesario
   - [ ] Actualizar validaciones de formulario

9. **VerificaciÃ³n final**
   - [ ] Ejecutar `mvn clean compile -DskipTests` sin errores
   - [ ] Verificar linting con `read_lints` tool
   - [ ] Reiniciar backend y probar endpoint completo
   - [ ] Verificar frontend si aplica

### âš ï¸ ADVERTENCIAS CRÃTICAS:

- **NUNCA** saltar ningÃºn paso del checklist
- **NUNCA** asumir que un paso "probablemente no es necesario"
- **SIEMPRE** verificar cada capa despuÃ©s de modificarla
- **SIEMPRE** hacer `mvn clean compile` despuÃ©s de cambios en entidades/dominio
- Este proceso puede tomar 30-45 minutos, pero es **OBLIGATORIO** para evitar horas de debugging

### ğŸ¯ EJEMPLO: Agregar campo `description` a `RoutingRule`

```
1. ALTER TABLE routing_rule ADD COLUMN description TEXT;
2. RoutingRuleEntity.java â†’ @Column(name = "description", columnDefinition = "TEXT") private String description;
3. RoutingRule.java â†’ private String description; + actualizar update()
4. CreateRoutingRuleDto.java â†’ String description
5. UpdateRoutingRuleDto.java â†’ String description
6. RoutingRuleResponseDto.java â†’ String description
7. RoutingRuleMapper.java â†’ agregar .description() en todos los mÃ©todos
8. RoutingRuleEntityMapper.java â†’ agregar .description() en toEntity/toDomain/updateEntity
9. seed-test-data.sql â†’ agregar description en INSERT INTO routing_rule
10. types.ts â†’ agregar description?: string
11. mvn clean compile -DskipTests
12. Reiniciar backend
13. Probar CRUD completo
```

---

## ğŸ—„ï¸ CONVENCIONES DE BASE DE DATOS

- Usar **UUID v7** para IDs (gen_random_uuid())
- Columnas obligatorias: `id`, `created_at`, `created_by`, `deleted`
- Soft delete: `deleted` (boolean), `deleted_at`, `deleted_by`
- Audit: `modified_at`, `modified_by`
- TEXT para descripciones largas, VARCHAR(N) para campos cortos

---

## ğŸ¨ CONVENCIONES DE CÃ“DIGO

- **DTOs**: Usar Java Records
- **Mappers**: Componentes Spring (`@Component`)
- **Validaciones**: Usar Jakarta Validation (`@NotBlank`, `@Size`, etc.)
- **Logging**: SLF4J con Lombok `@Slf4j`
- **DocumentaciÃ³n API**: Swagger/OpenAPI con `@Schema`

---

## ğŸš« PROHIBICIONES

- âŒ NO modificar solo la entidad JPA sin actualizar el dominio
- âŒ NO modificar solo el dominio sin actualizar los DTOs
- âŒ NO modificar DTOs sin actualizar mappers
- âŒ NO olvidar actualizar scripts de seed
- âŒ NO asumir que el IDE sincronizarÃ¡ automÃ¡ticamente - siempre hacer `mvn clean compile`

---

## ğŸ”„ FLUJO DE DATOS TÃPICO

```
Frontend Request
    â†“
REST Controller (infrastructure/adapter/inbound/rest)
    â†“
DTO (application/dto)
    â†“
Mapper (application/mapper) â†’ Domain Model
    â†“
Use Case (application/usecase) â†’ LÃ³gica de negocio
    â†“
Domain Model (domain/model/aggregate)
    â†“
Repository Port (domain/port/outbound)
    â†“
Repository Adapter (infrastructure/adapter/outbound/persistence)
    â†“
Entity Mapper (infrastructure/persistence/mapper)
    â†“
JPA Entity (infrastructure/persistence/entity)
    â†“
PostgreSQL Database
```

**Cada flecha implica un mapeo. Si agregas un campo, DEBES actualizar TODOS los mapeos.**

---

## ğŸ“¦ ESTRUCTURA DE PAQUETES

```
com.bank.signature/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ aggregate/      # Agregados (SignatureRequest, RoutingRule)
â”‚   â”‚   â”œâ”€â”€ entity/         # Entidades del dominio
â”‚   â”‚   â””â”€â”€ valueobject/    # Value Objects (Money, ChannelType)
â”‚   â”œâ”€â”€ port/
â”‚   â”‚   â”œâ”€â”€ inbound/        # Puertos de entrada (Use Cases)
â”‚   â”‚   â””â”€â”€ outbound/       # Puertos de salida (Repositories, Services)
â”‚   â”œâ”€â”€ service/            # Servicios de dominio
â”‚   â””â”€â”€ exception/          # Excepciones del dominio
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ usecase/            # Implementaciones de casos de uso
â”‚   â”œâ”€â”€ dto/                # DTOs (Request/Response)
â”‚   â”œâ”€â”€ mapper/             # Mappers (DTO â†” Domain)
â”‚   â””â”€â”€ service/            # Servicios de aplicaciÃ³n
â””â”€â”€ infrastructure/
    â”œâ”€â”€ adapter/
    â”‚   â”œâ”€â”€ inbound/
    â”‚   â”‚   â””â”€â”€ rest/       # Controladores REST
    â”‚   â””â”€â”€ outbound/
    â”‚       â”œâ”€â”€ persistence/ # Adaptadores JPA
    â”‚       â””â”€â”€ external/    # Clientes externos (Vault, etc.)
    â”œâ”€â”€ config/             # ConfiguraciÃ³n Spring
    â””â”€â”€ filter/             # Filtros HTTP
```

---

## ğŸ’¡ TIPS ADICIONALES

- Usa **Builder pattern** para objetos complejos
- Usa **Records** para DTOs inmutables
- Siempre valida en la capa de aplicaciÃ³n (DTOs)
- La lÃ³gica de negocio SOLO en el dominio
- Los mappers NO deben contener lÃ³gica de negocio
- Usa `@Transactional` solo en casos de uso y adapters de persistencia

---

**IMPORTANTE**: Si el usuario reporta que algo no funciona despuÃ©s de agregar un campo, 
revisa INMEDIATAMENTE este checklist completo antes de proponer soluciones.

