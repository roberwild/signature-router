<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context: 9.2 - Prometheus Metrics Export
  Generated: 2025-11-29
  Epic: 9 - Observability & SLO Tracking
  
  This file contains technical context for implementing comprehensive Prometheus metrics export
  (50+ metrics) for SLO tracking, proactive incident detection, and executive visibility.
-->
<story-context>
  <metadata>
    <story-id>9.2</story-id>
    <story-key>9-2-prometheus-metrics-export</story-key>
    <epic-id>9</epic-id>
    <title>Prometheus Metrics Export</title>
    <status>ready-for-dev</status>
    <story-points>5</story-points>
    <estimated-hours>21</estimated-hours>
    <confidence-level>high</confidence-level>
  </metadata>

  <user-story>
    <as-a>DevOps/SRE Team</as-a>
    <i-want>50+ comprehensive metrics exported to Prometheus</i-want>
    <so-that>Puedo monitorear SLOs (≥99.9% availability, P99 <300ms), detectar degradación proactivamente, y troubleshoot incidents eficientemente</so-that>
  </user-story>

  <business-value>
    <impact>Banking-grade observability: SLO monitoring + proactive alerting + fast debugging</impact>
    <metrics>
      <metric>MTTR reduction: 4h → 30min (87% improvement)</metric>
      <metric>MTTD reduction: 2h → 5min (96% improvement)</metric>
      <metric>Downtime cost avoided: $500K/year</metric>
      <metric>Engineering efficiency: +30% capacity freed from debugging</metric>
    </metrics>
    <nfr-mapping>NFR-O5, NFR-O6, NFR-O7, NFR-P1 (P99 <300ms), NFR-A1 (≥99.9% availability)</nfr-mapping>
  </business-value>

  <acceptance-criteria count="15">
    <criterion id="AC1" priority="critical">
      <title>Prometheus Metrics Endpoint Activo</title>
      <description>
        GET http://localhost:8080/actuator/prometheus retorna HTTP 200 con format text/plain.
        Endpoint público (no auth) para Prometheus scraper.
        Output contiene HELP + TYPE + samples en formato Prometheus.
      </description>
      <validation>curl http://localhost:8080/actuator/prometheus | head -20</validation>
    </criterion>

    <criterion id="AC2" priority="critical">
      <title>Business Metrics - Signature Requests</title>
      <description>
        Counters: signature_requests_created_total{channel, customer_id}, signature_requests_completed_total{status}
        Histogram: signature_requests_duration_seconds{quantile="0.5|0.95|0.99"}
        Buckets: 10s, 30s, 1min, 5min, 10min, 30min, 1h, 24h
      </description>
      <integration-point>CreateSignatureRequestUseCase, CompleteSignatureUseCase</integration-point>
    </criterion>

    <criterion id="AC3" priority="critical">
      <title>Business Metrics - Challenges</title>
      <description>
        Counters: challenges_sent_total{provider, channel}, challenges_completed_total{status}
        Histogram: challenges_duration_seconds{quantile="0.5|0.95|0.99"}
        Buckets: 5s, 10s, 30s, 1min, 5min, 10min
      </description>
      <integration-point>ChallengeService.sendChallenge(), CompleteChallengeUseCase</integration-point>
    </criterion>

    <criterion id="AC4" priority="high">
      <title>Business Metrics - Routing Decisions</title>
      <description>
        Counters: routing_decisions_total{rule_id, channel}, routing_fallback_triggered_total{from_channel, to_channel, reason}
        Timer: routing_rule_evaluation_duration_seconds
        Buckets: 1ms, 5ms, 10ms, 50ms, 100ms, 500ms
      </description>
      <integration-point>RoutingEngineService.evaluate(), FallbackChainManager</integration-point>
    </criterion>

    <criterion id="AC5" priority="high">
      <title>Provider Metrics (Integration with Epic 3)</title>
      <description>
        Verify existing metrics exported: provider_calls_total, provider_latency_seconds, provider_timeout_total,
        provider_error_rate, provider_circuit_breaker_state.
        NO create duplicates. Validate exposure in /actuator/prometheus.
      </description>
      <reference>Epic 3 Story 3.10 - Provider Metrics Tracking (already implemented)</reference>
    </criterion>

    <criterion id="AC6" priority="medium">
      <title>Infrastructure Metrics - JVM</title>
      <description>
        Automatic export via Micrometer: jvm_memory_used_bytes, jvm_gc_pause_seconds, jvm_threads_live.
        Expected: >20 JVM metrics.
      </description>
      <validation>curl ... | grep "^jvm_" | wc -l</validation>
    </criterion>

    <criterion id="AC7" priority="medium">
      <title>Infrastructure Metrics - HikariCP Database Pool</title>
      <description>
        Automatic export: hikaricp_connections_active, hikaricp_connections_idle, hikaricp_connections_pending,
        hikaricp_connections_max (debe ser 20 desde Story 1.2), hikaricp_connections_acquire_seconds.
      </description>
      <slo>Connection acquisition P95 <50ms, utilization <80%</slo>
    </criterion>

    <criterion id="AC8" priority="medium">
      <title>Infrastructure Metrics - Kafka Producer</title>
      <description>
        Automatic export: kafka_producer_record_send_total, kafka_producer_record_error_total, kafka_producer_record_send_rate.
        Expected: >10 Kafka producer metrics.
      </description>
      <validation>curl ... | grep "^kafka_producer" | wc -l</validation>
    </criterion>

    <criterion id="AC9" priority="critical">
      <title>HTTP Server Metrics (Spring Boot Actuator)</title>
      <description>
        Automatic export: http_server_requests_seconds_count{method, uri, status}, histogram buckets.
        SLO buckets: 50ms, 100ms, 300ms, 500ms, 1s (for P99 <300ms validation).
        Percentiles: 0.5, 0.95, 0.99
      </description>
      <slo>P99 latency <300ms (NFR-P1)</slo>
    </criterion>

    <criterion id="AC10" priority="high">
      <title>Custom @Timed Annotations en Use Cases</title>
      <description>
        Añadir @Timed annotations a 5 use cases críticos:
        - CreateSignatureRequestUseCase.execute() → signature.request.create
        - CompleteChallengeUseCase.execute() → challenge.complete
        - AbortSignatureRequestUseCase.execute() → signature.request.abort
        - RoutingEngineService.evaluate() → routing.rule.evaluate
        - ChallengeService.sendChallenge() → challenge.send
        Percentiles: 0.5, 0.95, 0.99
      </description>
      <dependency>Requires TimedAspect bean (AC12)</dependency>
    </criterion>

    <criterion id="AC11" priority="critical">
      <title>Metrics Configuration en application.yml</title>
      <description>
        management.endpoints.web.exposure.include: prometheus
        management.metrics.export.prometheus.enabled: true
        management.metrics.tags: application, environment, region
        management.metrics.distribution.percentiles-histogram: http.server.requests
        management.metrics.distribution.slo: 50ms, 100ms, 300ms, 500ms, 1s
      </description>
      <multi-environment>application-{local/uat/prod}.yml con tags environment-specific</multi-environment>
    </criterion>

    <criterion id="AC12" priority="high">
      <title>MetricsConfig Spring Configuration Bean</title>
      <description>
        Create MetricsConfig.java con beans:
        - TimedAspect (habilita @Timed annotations)
        - MeterFilter.commonTags (application, environment, region)
        - MeterFilter.deny (excluir /actuator/health y /actuator/prometheus de http_server_requests)
      </description>
      <location>infrastructure.config.MetricsConfig</location>
    </criterion>

    <criterion id="AC13" priority="critical">
      <title>Integration Tests - Prometheus Endpoint</title>
      <description>
        4+ integration tests con @SpringBootTest + TestRestTemplate:
        - testPrometheusEndpointAccessible() → HTTP 200
        - testBusinessMetricsExported() → signature_requests_created_total present
        - testJvmMetricsExported() → jvm_memory_used_bytes present
        - testCommonTagsApplied() → application="signature-router" in all metrics
      </description>
      <test-class>PrometheusMetricsIntegrationTest</test-class>
    </criterion>

    <criterion id="AC14" priority="high">
      <title>Unit Tests - MeterRegistry Custom Metrics</title>
      <description>
        6+ unit tests con SimpleMeterRegistry:
        - testSignatureRequestCreatedCounterIncremented()
        - testSignatureRequestDurationHistogramRecorded()
        - testChallengeSentCounterIncremented()
        - testRoutingDecisionCounterIncremented()
        - testMetricTagsApplied() (channel, provider, status tags)
        - testMetricFiltersApplied() (common tags + deny filters)
        Target coverage: >80%
      </description>
      <test-approach>SimpleMeterRegistry (NOT mock), AssertJ assertions</test-approach>
    </criterion>

    <criterion id="AC15" priority="medium">
      <title>Documentation - README Metrics Section</title>
      <description>
        Añadir sección "Observability - Prometheus Metrics" en README.md:
        - Business metrics table (signature requests, challenges, routing)
        - Provider metrics table (Epic 3 integration)
        - Infrastructure metrics list (JVM, HikariCP, Kafka)
        - Prometheus queries examples (request rate, P99 latency, error rate, availability)
        - Integration with Grafana (link to Story 9.3)
      </description>
      <length>~80 lines</length>
    </criterion>
  </acceptance-criteria>

  <artifacts>
    <documentation>
      <doc>
        <path>docs/sprint-artifacts/tech-spec-epic-9.md</path>
        <title>Epic 9 Technical Specification</title>
        <section>Story 9.2: Prometheus Metrics Export (lines 188-305)</section>
        <relevance>
          Acceptance Criteria detallados (AC1-AC6).
          Metrics Categories: Business (10+), Provider (Epic 3 integration), Infrastructure (automatic).
          Files to Create: MetricsConfig.java, BusinessMetrics.java, SignatureRequestMetrics.java, ChallengeMetrics.java.
          Files to Modify: application.yml, use cases (@Timed annotations).
        </relevance>
      </doc>

      <doc>
        <path>docs/sprint-artifacts/EPIC-9-INICIO.md</path>
        <title>Epic 9 Inicio Document</title>
        <section>Story 9.2 Planning (lines 37-47, 228-243)</section>
        <relevance>
          Scope: 50+ metrics (business + provider + infrastructure + JVM + DB + Kafka).
          Esfuerzo: 1 semana (5 SP).
          Dependencies: Epic 1 (Prometheus infrastructure), Epic 3 (provider metrics).
          Enables: Story 9.3 (Grafana Dashboards), Story 9.5 (Alerting Rules).
        </relevance>
      </doc>

      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>NFR-O (Observability) y NFR-P (Performance)</section>
        <relevance>
          NFR-O5: Prometheus metrics en /actuator/prometheus.
          NFR-O6: Business metrics (signature.created, challenge.sent, fallback.rate).
          NFR-O7: Technical metrics (provider.latency P50/P95/P99, provider.error_rate).
          NFR-P1: P99 latency <300ms (monitored via http_server_requests histogram).
          NFR-A1: 99.9% availability (monitored via error rate calculation).
        </relevance>
      </doc>

      <doc>
        <path>docs/architecture/07-observability-security.md</path>
        <title>Observability & Security Architecture</title>
        <section>Observability Strategy</section>
        <relevance>
          Three pillars: Metrics (Prometheus), Logging (ELK), Tracing (Jaeger).
          Metrics categories: RED (Rate, Errors, Duration), USE (Utilization, Saturation, Errors).
          SLO tracking: Availability ≥99.9%, Performance P99 <300ms, Error rate <0.1%.
        </relevance>
      </doc>

      <doc>
        <path>docs/sprint-artifacts/3-10-provider-metrics-tracking.md</path>
        <title>Story 3.10: Provider Metrics Tracking (Epic 3)</title>
        <section>Implementation Summary + AC validation</section>
        <relevance>
          Provider metrics already implemented (Status: done):
          - provider_calls_total{provider, status, channel_type, retried}
          - provider_latency_seconds{provider, quantile}
          - provider_timeout_total{provider}
          - provider_error_rate{provider} (gauge)
          - provider_circuit_breaker_state{provider, state}
          Story 9.2 AC5: Validate these metrics are exported in /actuator/prometheus (NO duplicar).
        </relevance>
      </doc>
    </documentation>

    <code>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/observability/metrics/ProviderMetrics.java</path>
        <kind>component</kind>
        <symbol>ProviderMetrics</symbol>
        <lines>1-150</lines>
        <reason>
          Pattern reference for Story 9.2: Component with MeterRegistry injection.
          Methods: recordProviderCall(), recordTimeout(), updateErrorRate().
          Use same pattern for SignatureRequestMetrics, ChallengeMetrics, RoutingMetrics.
        </reason>
      </artifact>

      <artifact>
        <path>src/main/java/com/bank/signature/application/usecase/CreateSignatureRequestUseCase.java</path>
        <kind>use-case</kind>
        <symbol>CreateSignatureRequestUseCase</symbol>
        <lines>1-100</lines>
        <reason>
          Use case to annotate with @Timed(value = "signature.request.create", percentiles = {0.5, 0.95, 0.99}).
          Integrate SignatureRequestMetrics for business counters (signature_requests_created_total).
        </reason>
      </artifact>

      <artifact>
        <path>src/main/java/com/bank/signature/application/service/ChallengeServiceImpl.java</path>
        <kind>service</kind>
        <symbol>ChallengeServiceImpl</symbol>
        <lines>1-200</lines>
        <reason>
          Service to integrate ChallengeMetrics. Method sendChallenge() already exists.
          Add @Timed annotation and metrics recording: challenges_sent_total{provider, channel}.
        </reason>
      </artifact>

      <artifact>
        <path>src/main/java/com/bank/signature/application/service/RoutingEngineServiceImpl.java</path>
        <kind>service</kind>
        <symbol>RoutingEngineServiceImpl</symbol>
        <lines>1-250</lines>
        <reason>
          Service to integrate RoutingMetrics. Method evaluate() selects routing rule.
          Add @Timed annotation and metrics recording: routing_decisions_total{rule_id, channel}.
        </reason>
      </artifact>

      <artifact>
        <path>src/main/resources/application.yml</path>
        <kind>configuration</kind>
        <symbol>application.yml</symbol>
        <lines>1-150</lines>
        <reason>
          Base configuration file to modify. Add management.metrics.export.prometheus config.
          Add distribution.percentiles-histogram and distribution.slo for SLO buckets.
        </reason>
      </artifact>

      <artifact>
        <path>src/main/resources/application-local.yml</path>
        <kind>configuration</kind>
        <symbol>application-local.yml</symbol>
        <lines>1-50</lines>
        <reason>
          Local environment config. Add tags: environment=local, region=local.
        </reason>
      </artifact>

      <artifact>
        <path>src/test/java/com/bank/signature/infrastructure/observability/metrics/ProviderMetricsTest.java</path>
        <kind>test</kind>
        <symbol>ProviderMetricsTest</symbol>
        <lines>1-200</lines>
        <reason>
          Unit test template. Uses SimpleMeterRegistry pattern (NOT mock).
          Tests verify counter.count(), histogram.count() values.
          Reuse pattern for SignatureRequestMetricsTest, ChallengeMetricsTest.
        </reason>
      </artifact>

      <artifact>
        <path>src/test/java/com/bank/signature/BaseIntegrationTest.java</path>
        <kind>test-base</kind>
        <symbol>BaseIntegrationTest</symbol>
        <lines>1-16</lines>
        <reason>
          Base class for integration tests. @SpringBootTest + @ActiveProfiles("test").
          Extend for PrometheusMetricsIntegrationTest.
        </reason>
      </artifact>
    </code>

    <dependencies>
      <java>
        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-actuator</artifactId>
          <scope>compile</scope>
          <note>Already included from Epic 1 Story 1.7. Provides /actuator/prometheus endpoint.</note>
          <status>existing</status>
        </dependency>

        <dependency>
          <groupId>io.micrometer</groupId>
          <artifactId>micrometer-registry-prometheus</artifactId>
          <scope>compile</scope>
          <note>Included automatically via spring-boot-starter-actuator. Prometheus registry for MeterRegistry.</note>
          <status>existing</status>
        </dependency>

        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-test</artifactId>
          <scope>test</scope>
          <note>Includes SimpleMeterRegistry for unit testing metrics.</note>
          <status>existing</status>
        </dependency>

        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-aop</artifactId>
          <scope>compile</scope>
          <note>Required for @Timed aspect (TimedAspect bean). Already included from Epic 1.</note>
          <status>existing</status>
        </dependency>
      </java>

      <note>NO new Maven dependencies required. All dependencies already included from Epic 1 (Actuator, Micrometer, AOP).</note>
    </dependencies>
  </artifacts>

  <interfaces>
    <interface>
      <name>MeterRegistry</name>
      <kind>Spring Micrometer API</kind>
      <signature>
        public interface MeterRegistry {
          Counter counter(String name, String... tags);
          Timer timer(String name, String... tags);
          Gauge gauge(String name, Iterable&lt;Tag&gt; tags, ToDoubleFunction&lt;T&gt; valueFunction, T obj);
        }
      </signature>
      <path>io.micrometer.core.instrument.MeterRegistry</path>
      <usage>Dependency injection en SignatureRequestMetrics, ChallengeMetrics, RoutingMetrics components</usage>
    </interface>

    <interface>
      <name>SignatureRequestMetrics.recordCreated</name>
      <kind>Method signature (to create)</kind>
      <signature>
        public void recordCreated(SignatureRequest request) {
          // Increment counter: signature.requests.created.total
          // Tags: channel (request.channelType), customer_id (request.customerId pseudonimizado)
        }
      </signature>
      <path>com.bank.signature.infrastructure.observability.metrics.SignatureRequestMetrics</path>
      <usage>Llamado desde CreateSignatureRequestUseCase después de crear request</usage>
    </interface>

    <interface>
      <name>SignatureRequestMetrics.recordCompleted</name>
      <kind>Method signature (to create)</kind>
      <signature>
        public void recordCompleted(SignatureRequest request) {
          // Increment counter: signature.requests.completed.total{status}
          // Record histogram: signature.requests.duration.seconds (desde createdAt hasta completedAt)
        }
      </signature>
      <path>com.bank.signature.infrastructure.observability.metrics.SignatureRequestMetrics</path>
      <usage>Llamado desde CompleteSignatureUseCase / AbortSignatureRequestUseCase</usage>
    </interface>

    <interface>
      <name>ChallengeMetrics.recordSent</name>
      <kind>Method signature (to create)</kind>
      <signature>
        public void recordSent(SignatureChallenge challenge, ProviderType provider) {
          // Increment counter: challenges.sent.total
          // Tags: provider (TWILIO/FCM/VOICE), channel (challenge.channelType)
        }
      </signature>
      <path>com.bank.signature.infrastructure.observability.metrics.ChallengeMetrics</path>
      <usage>Llamado desde ChallengeService.sendChallenge() después de enviar challenge</usage>
    </interface>

    <interface>
      <name>RoutingMetrics.recordDecision</name>
      <kind>Method signature (to create)</kind>
      <signature>
        public void recordDecision(RoutingRule rule, ChannelType selectedChannel) {
          // Increment counter: routing.decisions.total
          // Tags: rule_id (rule.id), channel (selectedChannel)
        }
      </signature>
      <path>com.bank.signature.infrastructure.observability.metrics.RoutingMetrics</path>
      <usage>Llamado desde RoutingEngineService.evaluate() después de seleccionar regla</usage>
    </interface>

    <interface>
      <name>@Timed</name>
      <kind>Micrometer annotation</kind>
      <signature>
        @Timed(value = "metric.name", description = "...", percentiles = {0.5, 0.95, 0.99})
        public ReturnType methodName(params) { ... }
      </signature>
      <path>io.micrometer.core.annotation.Timed</path>
      <usage>Añadir a 5 use cases críticos (AC10). Requires TimedAspect bean (AC12).</usage>
    </interface>

    <interface>
      <name>TimedAspect</name>
      <kind>Micrometer aspect</kind>
      <signature>
        public class TimedAspect {
          public TimedAspect(MeterRegistry registry) { ... }
        }
      </signature>
      <path>io.micrometer.core.aop.TimedAspect</path>
      <usage>Create bean in MetricsConfig.java para habilitar @Timed annotations</usage>
    </interface>
  </interfaces>

  <constraints>
    <constraint type="architectural">
      <rule>Metrics components DEBEN estar en infrastructure.observability.metrics package</rule>
      <rationale>Separación de concerns: observability es infrastructure concern, NO domain</rationale>
      <source>Hexagonal Architecture + Epic 9 Tech Spec</source>
      <priority>critical</priority>
    </constraint>

    <constraint type="architectural">
      <rule>Domain layer NO puede depender de MeterRegistry o Micrometer</rule>
      <rationale>Domain purity: metrics registration es infrastructure detail</rationale>
      <source>HexagonalArchitectureTest validará con ArchUnit</source>
      <priority>critical</priority>
    </constraint>

    <constraint type="integration">
      <rule>NO duplicar provider metrics de Epic 3 Story 3.10</rule>
      <rationale>Provider metrics ya existen: provider_calls_total, provider_latency, provider_error_rate. Solo validar exposición en /actuator/prometheus.</rationale>
      <source>AC5 + Epic 3 Story 3.10 integration</source>
      <priority>critical</priority>
    </constraint>

    <constraint type="naming">
      <rule>Prometheus metric names DEBEN usar snake_case con dots como separadores</rule>
      <rationale>Prometheus best practices: signature.requests.created.total (NOT signatureRequestsCreatedTotal)</rationale>
      <source>Prometheus naming conventions</source>
      <priority>high</priority>
    </constraint>

    <constraint type="naming">
      <rule>Counters DEBEN tener sufijo _total</rule>
      <rationale>Prometheus convention: counters son acumulativos, siempre _total suffix</rationale>
      <source>Prometheus naming conventions</source>
      <priority>high</priority>
    </constraint>

    <constraint type="naming">
      <rule>Histogram/Timer metrics DEBEN usar base unit seconds (NOT milliseconds)</rule>
      <rationale>Prometheus base units: duration en seconds, size en bytes</rationale>
      <source>Prometheus naming conventions</source>
      <priority>high</priority>
    </constraint>

    <constraint type="performance">
      <rule>MeterRegistry lookups DEBEN ser cacheados como fields en metrics components</rule>
      <rationale>Evitar registry lookup en cada call (performance optimization)</rationale>
      <source>Story 3.10 learnings: ProviderMetrics pattern</source>
      <priority>medium</priority>
    </constraint>

    <constraint type="performance">
      <rule>Metrics overhead DEBE ser <1% latency impact</rule>
      <rationale>Micrometer es low-overhead library, pero exceso de metrics puede afectar performance</rationale>
      <source>NFR-P1 P99 latency <300ms</source>
      <priority>high</priority>
    </constraint>

    <constraint type="configuration">
      <rule>Histogram buckets DEBEN configurarse con SLO keyword para limitar memory usage</rule>
      <rationale>SLO buckets limitan histogramas a buckets específicos (50ms, 100ms, 300ms, 500ms, 1s) evitando infinitos buckets</rationale>
      <source>application.yml management.metrics.distribution.slo</source>
      <priority>high</priority>
    </constraint>

    <constraint type="configuration">
      <rule>Common tags DEBEN aplicarse a TODAS las métricas vía MeterFilter</rule>
      <rationale>Tags comunes (application, environment, region) permiten filtering en Prometheus/Grafana multi-environment</rationale>
      <source>AC12 MetricsConfig.commonTagsFilter</source>
      <priority>high</priority>
    </constraint>

    <constraint type="configuration">
      <rule>Actuator health check requests DEBEN excluirse de http_server_requests metrics</rule>
      <rationale>Health checks son muy frecuentes (cada 10s) y distorsionan métricas de latency/throughput</rationale>
      <source>AC12 MetricsConfig.denyHealthCheckMetrics</source>
      <priority>medium</priority>
    </constraint>

    <constraint type="testing">
      <rule>Unit tests DEBEN usar SimpleMeterRegistry, NO mock MeterRegistry</rule>
      <rationale>SimpleMeterRegistry es lightweight in-memory registry para testing, más realista que mock</rationale>
      <source>Story 3.10 learnings + Micrometer testing best practices</source>
      <priority>high</priority>
    </constraint>

    <constraint type="testing">
      <rule>Integration tests DEBEN verificar /actuator/prometheus endpoint contiene métricas esperadas</rule>
      <rationale>Validar export completo end-to-end, no solo que métrica fue registrada</rationale>
      <source>AC13</source>
      <priority>critical</priority>
    </constraint>

    <constraint type="observability">
      <rule>Percentiles DEBEN calcularse via histogram (NOT server-side percentile calculation)</rule>
      <rationale>Server-side percentiles son expensive (high memory). Histogram permite Prometheus calcular percentiles desde buckets.</rationale>
      <source>application.yml distribution.percentiles-histogram: true</source>
      <priority>high</priority>
    </constraint>

    <constraint type="observability">
      <rule>Customer ID en metrics DEBE ser pseudonimizado (HMAC-SHA256 hash)</rule>
      <rationale>GDPR compliance: NO exponer PII en métricas. Usar PseudonymizationService para hash customer_id.</rationale>
      <source>Epic 8 Story 8.3 Pseudonymization + GDPR requirements</source>
      <priority>critical</priority>
    </constraint>
  </constraints>

  <tests>
    <standards>
      Testing strategy para Story 9.2:
      - **Unit Tests**: JUnit 5 + SimpleMeterRegistry para metrics components (NO mock)
      - **Integration Tests**: @SpringBootTest + TestRestTemplate para /actuator/prometheus validation
      - **Coverage Target**: >80% para metrics components
      - **Test Organization**:
        * Unit tests en src/test/java/.../observability/metrics/*MetricsTest.java
        * Integration tests en src/test/java/.../infrastructure/PrometheusMetricsIntegrationTest.java
      - **Assertions**: AssertJ para fluent assertions, verify counter.count(), histogram.count(), gauge.value()
      - **Test Naming**: should{Behavior}When{Condition} pattern
    </standards>

    <test-ideas>
      <test-idea ac="AC14">
        <name>testSignatureRequestCreatedCounterIncremented</name>
        <approach>
          Unit test: Create SimpleMeterRegistry, inject to SignatureRequestMetrics.
          Call recordCreated(request) 2 veces.
          Verify signature.requests.created.total{channel="SMS", customer_id="HASH..."} counter = 2.0
        </approach>
        <test-class>SignatureRequestMetricsTest</test-class>
      </test-idea>

      <test-idea ac="AC14">
        <name>testSignatureRequestDurationHistogramRecorded</name>
        <approach>
          Unit test: Create SignatureRequest con createdAt hace 2 minutos, completedAt now.
          Call recordCompleted(request).
          Verify signature.requests.duration.seconds histogram count = 1, totalTime > 120s.
        </approach>
        <test-class>SignatureRequestMetricsTest</test-class>
      </test-idea>

      <test-idea ac="AC14">
        <name>testChallengeSentCounterIncremented</name>
        <approach>
          Unit test: Call ChallengeMetrics.recordSent(challenge, ProviderType.TWILIO).
          Verify challenges.sent.total{provider="TWILIO", channel="SMS"} counter = 1.0
        </approach>
        <test-class>ChallengeMetricsTest</test-class>
      </test-idea>

      <test-idea ac="AC14">
        <name>testRoutingDecisionCounterIncremented</name>
        <approach>
          Unit test: Call RoutingMetrics.recordDecision(rule, ChannelType.SMS).
          Verify routing.decisions.total{rule_id="rule-123", channel="SMS"} counter = 1.0
        </approach>
        <test-class>RoutingMetricsTest</test-class>
      </test-idea>

      <test-idea ac="AC14">
        <name>testMetricTagsApplied</name>
        <approach>
          Unit test: Call recordCreated() con different channels (SMS, PUSH, VOICE).
          Verify counter.tag("channel", "SMS"), counter.tag("channel", "PUSH") tienen counts correctos.
        </approach>
        <test-class>SignatureRequestMetricsTest</test-class>
      </test-idea>

      <test-idea ac="AC14">
        <name>testMetricFiltersApplied</name>
        <approach>
          Unit test: Setup MeterRegistry con commonTagsFilter.
          Register counter, verify tag "application"="signature-router" presente.
        </approach>
        <test-class>BusinessMetricsTest</test-class>
      </test-idea>

      <test-idea ac="AC13">
        <name>testPrometheusEndpointAccessible</name>
        <approach>
          Integration test: @SpringBootTest, inject TestRestTemplate.
          GET /actuator/prometheus.
          Verify HTTP 200, Content-Type contains "text/plain".
        </approach>
        <test-class>PrometheusMetricsIntegrationTest</test-class>
      </test-idea>

      <test-idea ac="AC13">
        <name>testBusinessMetricsExported</name>
        <approach>
          Integration test: GET /actuator/prometheus.
          Verify response body contains "signature_requests_created_total", "challenges_sent_total", "routing_decisions_total".
        </approach>
        <test-class>PrometheusMetricsIntegrationTest</test-class>
      </test-idea>

      <test-idea ac="AC13">
        <name>testJvmMetricsExported</name>
        <approach>
          Integration test: GET /actuator/prometheus.
          Verify response body contains "jvm_memory_used_bytes", "jvm_gc_pause_seconds", "jvm_threads_live".
          Count metrics: grep "^jvm_" | wc -l, assert >20.
        </approach>
        <test-class>PrometheusMetricsIntegrationTest</test-class>
      </test-idea>

      <test-idea ac="AC13">
        <name>testCommonTagsApplied</name>
        <approach>
          Integration test: GET /actuator/prometheus.
          Verify response body contains tag application="signature-router", environment="test" in multiple metrics.
        </approach>
        <test-class>PrometheusMetricsIntegrationTest</test-class>
      </test-idea>
    </test-ideas>
  </tests>

  <notes>
    <dev-note priority="critical">
      **Pattern Reuse from Epic 3 Story 3.10**: ProviderMetrics component es template perfecto.
      Usar mismo pattern: @Component + @RequiredArgsConstructor + MeterRegistry injection.
      Cache counter/histogram references como private final fields para performance.
      Apply pattern to SignatureRequestMetrics, ChallengeMetrics, RoutingMetrics.
    </dev-note>

    <dev-note priority="critical">
      **Epic 3 Integration (AC5)**: Provider metrics ya implementados en Story 3.10.
      NO duplicar métricas: provider_calls_total, provider_latency, provider_timeout_total, provider_error_rate.
      Task 7: Solo VALIDAR que estas métricas se exportan en /actuator/prometheus.
      Si NO aparecen, debugging: verificar ProviderMetrics bean, MeterFilter.deny NO excluye provider metrics.
    </dev-note>

    <dev-note priority="high">
      **@Timed Annotations (AC10)**: Requires TimedAspect bean configurado ANTES.
      Task 2: Create MetricsConfig.java con TimedAspect bean.
      Task 3: Añadir @Timed annotations a 5 use cases.
      Validation: mvn spring-boot:run, verify métricas signature.request.create_seconds_count en /actuator/prometheus.
    </dev-note>

    <dev-note priority="high">
      **Histogram Buckets Configuration**: Personalizar buckets para cada métrica.
      application.yml management.metrics.distribution.slo:
      - http.server.requests: 50ms, 100ms, 300ms, 500ms, 1s (SLO P99 <300ms)
      - signature.requests.duration.seconds: 10s, 30s, 1min, 5min, 10min (user journey duration)
      - challenges.duration.seconds: 5s, 10s, 30s, 1min (challenge completion time)
      - routing.rule.evaluation.duration.seconds: 1ms, 5ms, 10ms, 50ms (routing engine performance)
    </dev-note>

    <dev-note priority="high">
      **Pseudonymization de Customer ID (AC2)**: CRITICAL for GDPR compliance.
      signature.requests.created.total tag customer_id DEBE ser HMAC-SHA256 hash (NOT plain customer ID).
      Usar PseudonymizationService.pseudonymize(customerId) antes de registrar métrica.
      Reference: Epic 8 Story 8.3 Pseudonymization Service.
    </dev-note>

    <dev-note priority="medium">
      **MeterFilter.deny for Actuator Endpoints (AC12)**: Excluir /actuator/health y /actuator/prometheus.
      Rationale: Health checks cada 10s + Prometheus scrape cada 10s = 2 req/sec de ruido en métricas.
      Distorsiona P99 latency y request rate metrics.
      Implementation: MeterFilter.deny(id -> id.getName().startsWith("http.server.requests") && "/actuator/health".equals(id.getTag("uri")))
    </dev-note>

    <dev-note priority="medium">
      **Common Tags Multi-Environment (AC11, AC12)**: Tags permiten filtering en Grafana.
      application-local.yml: environment=local, region=local
      application-uat.yml: environment=uat, region=us-east-1
      application-prod.yml: environment=prod, region=us-east-1
      MeterFilter.commonTags() aplica tags a TODAS las métricas automáticamente.
    </dev-note>

    <dev-note priority="low">
      **Prometheus Best Practices**:
      - Metric names: snake_case con dots (signature.requests.created.total)
      - Counters: suffix _total (provider.calls.total, challenges.sent.total)
      - Base units: seconds for duration (NOT milliseconds), bytes for size (NOT KB)
      - Cardinality: ~50 metrics × ~5 tags × ~3 values per tag = ~750 time series (safe, <10K threshold)
    </dev-note>

    <dev-note priority="low">
      **Manual Testing Checklist**:
      1. Start Docker Compose (postgres, kafka, vault)
      2. Start app: mvn spring-boot:run -Dspring-boot.run.profiles=local
      3. Verify /actuator/prometheus accessible: curl http://localhost:8080/actuator/prometheus | head -50
      4. Create signature request via Postman (POST /api/v1/signature-requests)
      5. Verify metric incremented: curl ... | grep signature_requests_created_total
      6. Verify HTTP metrics: curl ... | grep "http_server_requests"
      7. Verify JVM metrics: curl ... | grep "^jvm_" | wc -l (expect >20)
      8. Verify common tags: curl ... | grep 'application="signature-router"'
    </dev-note>

    <dev-note priority="critical">
      **Testing Strategy**: Unit tests usan SimpleMeterRegistry (NO mock MeterRegistry).
      Create SimpleMeterRegistry en @BeforeEach, inject to metrics components.
      Verify counter.count(), histogram.count(), histogram.totalTime() con AssertJ.
      Integration tests: @SpringBootTest + TestRestTemplate GET /actuator/prometheus + parse response body.
      NO usar @MockBean MeterRegistry (anti-pattern, no realistic).
    </dev-note>
  </notes>

  <learnings-from-previous-stories>
    <source>Epic 3 Story 3.10 - Provider Metrics Tracking (Status: done)</source>

    <learning category="pattern">
      **ProviderMetrics Component Pattern**: Centraliza metrics con MeterRegistry injection.
      @Component + @RequiredArgsConstructor + private final MeterRegistry meterRegistry.
      Methods: recordProviderCall(), recordTimeout(), updateErrorRate().
      → **Apply to Story 9.2**: Use same pattern for SignatureRequestMetrics, ChallengeMetrics, RoutingMetrics.
    </learning>

    <learning category="performance">
      **MeterRegistry Caching**: Store counter/histogram references como private final fields.
      Evita registry lookups en cada call (performance optimization).
      Example: private final Counter createdCounter = meterRegistry.counter("signature.requests.created.total");
      → **Apply to Story 9.2**: Cache all counter/histogram/timer references in metrics components.
    </learning>

    <learning category="tagging">
      **Tag Strategy**: Counters con múltiples tags permite queries granulares en Prometheus.
      provider.calls.total{provider="SMS", status="success", channel_type="SMS"}
      → **Apply to Story 9.2**: Use tags channel, provider, status, rule_id en business metrics.
    </learning>

    <learning category="testing">
      **SimpleMeterRegistry Testing**: Unit tests NO usan mock MeterRegistry.
      SimpleMeterRegistry es lightweight in-memory registry para testing (realistic).
      Verify counter.count(), histogram.count() values directamente con AssertJ.
      → **Apply to Story 9.2**: Use SimpleMeterRegistry en todos los unit tests.
    </learning>

    <learning category="integration">
      **Prometheus Auto-Export**: /actuator/prometheus endpoint auto-exporta TODAS las métricas.
      No requiere configuración adicional si micrometer-registry-prometheus está en classpath.
      → **Apply to Story 9.2**: Metrics auto-exported, validar en integration test AC13.
    </learning>

    <learning category="configuration">
      **Histogram Buckets Customization**: Personalizar buckets en application.yml para métricas específicas.
      management.metrics.distribution.slo: 50ms, 100ms, 300ms (SLO buckets).
      → **Apply to Story 9.2**: Custom buckets para http.server.requests, signature.requests.duration, challenges.duration.
    </learning>

    <learning category="observability">
      **Error Rate Calculation**: Gauge metrics requieren scheduled task para update.
      ProviderErrorRateCalculator usa @Scheduled(fixedDelay=10000) para calcular cada 10s.
      → **Apply to Story 9.2**: NO required for Story 9.2 (no gauges calculados). Prometheus calcula error rate via query.
    </learning>

    <source>Epic 9 Story 9.1 - Structured JSON Logging & MDC (Status: done)</source>

    <learning category="integration">
      **MDC Context for Metrics**: TraceId en MDC context puede usarse como tag en metrics.
      → **Apply to Story 9.2**: Future enhancement (Story 9.4 Distributed Tracing), no en Story 9.2 scope.
    </learning>

    <learning category="observability">
      **ELK Integration**: Logs y metrics son complementarios (logs para "why", metrics para "what/when/how many").
      → **Apply to Story 9.2**: Metrics permiten alerting proactivo, logs proveen debugging context.
    </learning>
  </learnings-from-previous-stories>

  <references>
    <reference>
      <title>Story 9.2 Full Specification</title>
      <path>docs/sprint-artifacts/9-2-prometheus-metrics-export.md</path>
    </reference>
    <reference>
      <title>Epic 9 Technical Specification</title>
      <path>docs/sprint-artifacts/tech-spec-epic-9.md</path>
    </reference>
    <reference>
      <title>Epic 3 Story 3.10 - Provider Metrics Tracking</title>
      <path>docs/sprint-artifacts/3-10-provider-metrics-tracking.md</path>
    </reference>
    <reference>
      <title>PRD - Non-Functional Requirements (Observability + Performance)</title>
      <path>docs/prd.md</path>
    </reference>
    <reference>
      <title>Architecture - Observability & Security</title>
      <path>docs/architecture/07-observability-security.md</path>
    </reference>
    <reference>
      <title>Prometheus Best Practices</title>
      <url>https://prometheus.io/docs/practices/naming/</url>
    </reference>
    <reference>
      <title>Micrometer Documentation</title>
      <url>https://micrometer.io/docs/concepts</url>
    </reference>
  </references>
</story-context>
