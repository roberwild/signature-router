<?xml version="1.0" encoding="UTF-8"?>
<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.8</storyId>
    <title>Provider Timeout Configuration</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-28</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-8-provider-timeout-configuration.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>System Administrator / SRE</asA>
    <iWant>Timeout configuration granular y configurable per-provider con Resilience4j TimeLimiter</iWant>
    <soThat>Pueda ajustar timeouts según características de cada provider y evitar hang indefinido</soThat>
    <tasks>
      <task id="1" estimated="45min">
        <name>Configure Resilience4j TimeLimiter Instances</name>
        <description>Configurar 4 instancias de TimeLimiter en application.yml (smsTimeout: 5s, pushTimeout: 3s, voiceTimeout: 10s, biometricTimeout: 2s) con cancelRunningFuture=true y multi-environment profiles</description>
        <subtasks>
          <subtask>Actualizar pom.xml con resilience4j-timelimiter (si no está)</subtask>
          <subtask>Crear sección resilience4j.timelimiter en application.yml con 4 instancias</subtask>
          <subtask>Crear application-local.yml overrides (timeouts permissive: 10s)</subtask>
          <subtask>Crear application-prod.yml overrides (timeouts strict: 3-5s)</subtask>
          <subtask>Configurar ScheduledExecutorService bean (10 threads, provider-timeout-{n})</subtask>
        </subtasks>
      </task>
      <task id="2" estimated="1h">
        <name>Refactor Provider Interface to Async</name>
        <description>Agregar método sendChallengeAsync() que retorna CompletableFuture&lt;ProviderResult&gt; en SignatureProviderPort y todos los providers (TwilioSmsProvider, PushNotificationProvider, VoiceCallProvider, BiometricProvider)</description>
        <subtasks>
          <subtask>Actualizar SignatureProviderPort con CompletableFuture&lt;ProviderResult&gt; sendChallengeAsync(SignatureChallenge, String)</subtask>
          <subtask>Implementar sendChallengeAsync() en TwilioSmsProvider (CompletableFuture.supplyAsync)</subtask>
          <subtask>Implementar sendChallengeAsync() en PushNotificationProvider</subtask>
          <subtask>Implementar sendChallengeAsync() en VoiceCallProvider</subtask>
          <subtask>Implementar sendChallengeAsync() en BiometricProvider (CompletableFuture.completedFuture)</subtask>
          <subtask>Inject ScheduledExecutorService en cada provider</subtask>
          <subtask>Update JavaDoc completo en SignatureProviderPort y providers</subtask>
        </subtasks>
      </task>
      <task id="3" estimated="1h 30min">
        <name>Implement TimeLimiter Decoration in SignatureProviderAdapter</name>
        <description>Decorar provider calls con TimeLimiter.decorateFuture(), handle TimeoutException, agregar campo timedOut en ProviderResult, agregar Prometheus metrics</description>
        <subtasks>
          <subtask>Inject TimeLimiterRegistry en SignatureProviderAdapter</subtask>
          <subtask>Modificar sendChallenge(): determinar provider, seleccionar TimeLimiter instance, decorar con decorateFuture()</subtask>
          <subtask>Agregar campo timedOut boolean en ProviderResult value object</subtask>
          <subtask>Agregar Prometheus metrics: provider.timeout.total counter</subtask>
          <subtask>Logging completo: log.warn() con traceId, provider, duration</subtask>
        </subtasks>
      </task>
      <task id="4" estimated="45min">
        <name>Unit Tests - Provider Async Methods</name>
        <description>Crear tests unitarios para métodos async de cada provider (4 test classes)</description>
      </task>
      <task id="5" estimated="1h">
        <name>Unit Tests - SignatureProviderAdapter Timeout Logic</name>
        <description>Crear SignatureProviderAdapterTimeoutTest con 5 tests (timeout scenario, success scenario, metrics, logging, cancel future)</description>
      </task>
      <task id="6" estimated="1h">
        <name>Integration Tests - Slow Provider Simulation</name>
        <description>Crear ProviderTimeoutIntegrationTest con mock provider sleep(6000ms), verify timeout after 5s, verify metrics export, test multi-environment config</description>
      </task>
      <task id="7" estimated="45min">
        <name>Update Documentation</name>
        <description>Actualizar README con Provider Timeouts section, CHANGELOG entry, JavaDoc completo</description>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1" priority="HIGH">
      <description>Resilience4j TimeLimiter configurado en application.yml con 4 instancias: smsTimeout (5s), pushTimeout (3s), voiceTimeout (10s), biometricTimeout (2s)</description>
      <verification>Verificar application.yml contiene sección resilience4j.timelimiter con 4 instances configuradas y cancelRunningFuture=true</verification>
    </criterion>
    <criterion id="AC2" priority="HIGH">
      <description>Cada provider implementa método sendChallengeAsync() que retorna CompletableFuture&lt;ProviderResult&gt;</description>
      <verification>Verificar SignatureProviderPort tiene método async, y 4 providers implementan sendChallengeAsync()</verification>
    </criterion>
    <criterion id="AC3" priority="HIGH">
      <description>SignatureProviderAdapter decora cada provider call con @TimeLimiter, timeout exceeded retorna ProviderResult.failure("TIMEOUT")</description>
      <verification>Verificar SignatureProviderAdapter usa TimeLimiterRegistry, decora con decorateFuture(), handle TimeoutException</verification>
    </criterion>
    <criterion id="AC4" priority="HIGH">
      <description>Configuration property cancelRunningFuture=true para cada TimeLimiter, Thread pool configurado con 10 threads</description>
      <verification>Verificar application.yml tiene cancelRunningFuture=true, ScheduledExecutorService bean creado</verification>
    </criterion>
    <criterion id="AC5" priority="MEDIUM">
      <description>Timeout events publicados a Prometheus metrics: provider.timeout.total counter</description>
      <verification>Verificar MeterRegistry.counter("provider.timeout.total") incremented en timeout events</verification>
    </criterion>
    <criterion id="AC6" priority="MEDIUM">
      <description>Timeout values expuestos en /actuator/configprops (masked secrets)</description>
      <verification>Verificar GET /actuator/configprops muestra resilience4j.timelimiter.instances</verification>
    </criterion>
    <criterion id="AC7" priority="HIGH">
      <description>Integration test con Testcontainers: mock provider responde después de 6s (excede timeout 5s), verify ProviderResult.failure("TIMEOUT")</description>
      <verification>Verificar ProviderTimeoutIntegrationTest.java con test que simula slow provider, duration ~5s NO 6s, ProviderResult.timedOut=true</verification>
    </criterion>
    <criterion id="AC8" priority="HIGH">
      <description>Unit tests para SignatureProviderAdapter: testSendChallenge_whenProviderTimesOut_shouldReturnFailure(), testSendChallenge_whenProviderRespondsInTime_shouldReturnSuccess(), testAsyncExecution_whenTimeoutExceeded_shouldCancelFuture()</description>
      <verification>Verificar SignatureProviderAdapterTimeoutTest.java con 5+ test methods, coverage > 85%</verification>
    </criterion>
    <criterion id="AC9" priority="MEDIUM">
      <description>Multi-environment configuration: application-local.yml (timeouts permissive 10s), application-uat.yml (5s), application-prod.yml (strict 3-5s)</description>
      <verification>Verificar 3 archivos de configuración con timeout values específicos por environment</verification>
    </criterion>
    <criterion id="AC10" priority="HIGH">
      <description>ProviderResult incluye campo timedOut boolean (true si failure causado por timeout, false otherwise)</description>
      <verification>Verificar ProviderResult.java record tiene campo timedOut boolean, factory method timeout()</verification>
    </criterion>
    <criterion id="AC11" priority="MEDIUM">
      <description>Logging detallado en timeout events: log.warn() con traceId, provider, duration, challenge_id</description>
      <verification>Verificar SignatureProviderAdapter logs con MDC traceId, level WARNING (not ERROR)</verification>
    </criterion>
    <criterion id="AC12" priority="LOW">
      <description>Documentation completa: README Provider Timeouts section, CHANGELOG entry, JavaDoc en SignatureProviderAdapter.sendChallengeAsync()</description>
      <verification>Verificar README.md tiene Provider Timeouts section, CHANGELOG.md Story 3.8 entry, JavaDoc completo</verification>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification - Multi-Provider Integration</title>
        <section>Resilience4j Configuration (Section 8: Provider Timeout Configuration)</section>
        <snippet>AC9: Provider Timeout Configuration - Resilience4j TimeLimiter applied with 5s timeout, TimeLimiter configured via @TimeLimiter(name="externalHttp"), On timeout: Return ProviderResult.failure("TIMEOUT"), CompletableFuture cancelled (cancelRunningFuture=true)</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture/06-resilience-strategy.md</path>
        <title>Resilience Strategy - Patterns &amp; Configuration</title>
        <section>2. Timeout Strategy</section>
        <snippet>Timeout Configuration: externalHttp (5s), internalHttp (3s), database (2s), kafka (1500ms). Implementation: @TimeLimiter(name="externalHttp", fallbackMethod="sendFallback") with CompletableFuture.supplyAsync()</snippet>
      </artifact>
      <artifact>
        <path>docs/prd.md</path>
        <title>Product Requirements Document - Signature Router</title>
        <section>NFR-P2: P99 Latency &lt; 3s</section>
        <snippet>P99 latency for complete signature flow must be under 3 seconds. Timeout max 5s on external HTTP calls to meet this requirement</snippet>
      </artifact>
      <artifact>
        <path>docs/architecture/02-hexagonal-structure.md</path>
        <title>Hexagonal Architecture Structure</title>
        <section>Outbound Ports - SignatureProviderPort</section>
        <snippet>Provider abstraction interface in domain/port/outbound/, ZERO infrastructure dependencies, returns domain value objects (ProviderResult, HealthStatus)</snippet>
      </artifact>
    </docs>
    
    <code>
      <artifact>
        <path>src/main/java/com/bank/signature/domain/port/outbound/SignatureProviderPort.java</path>
        <kind>interface</kind>
        <symbol>SignatureProviderPort</symbol>
        <lines>1-110</lines>
        <reason>Domain interface que necesita agregar método sendChallengeAsync() - actualmente solo tiene sendChallenge() sync. CRITICAL: Mantener backward compatibility, NO eliminar método sync.</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
        <kind>value-object</kind>
        <symbol>ProviderResult</symbol>
        <lines>1-120</lines>
        <reason>Java 21 record que necesita agregar campo boolean timedOut. Actualmente tiene: success, providerChallengeId, providerProof, errorCode, errorMessage, timestamp. Agregar factory method timeout(String message).</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/twilio/TwilioSmsProvider.java</path>
        <kind>provider-implementation</kind>
        <symbol>TwilioSmsProvider</symbol>
        <lines>1-150</lines>
        <reason>SMS provider que implementa SignatureProviderPort - necesita implementar sendChallengeAsync() con CompletableFuture.supplyAsync(() -> sendChallenge(challenge), executorService)</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/push/PushNotificationProvider.java</path>
        <kind>provider-implementation</kind>
        <symbol>PushNotificationProvider</symbol>
        <lines>1-150</lines>
        <reason>Push provider - implementar sendChallengeAsync() siguiendo mismo patrón que TwilioSmsProvider</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/voice/VoiceCallProvider.java</path>
        <kind>provider-implementation</kind>
        <symbol>VoiceCallProvider</symbol>
        <lines>1-150</lines>
        <reason>Voice provider - implementar sendChallengeAsync() siguiendo mismo patrón</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/adapter/outbound/provider/biometric/BiometricProvider.java</path>
        <kind>provider-implementation</kind>
        <symbol>BiometricProvider</symbol>
        <lines>19-103</lines>
        <reason>Biometric stub provider - implementar sendChallengeAsync() con CompletableFuture.completedFuture(sendChallenge()) ya que es stub instant</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/application/service/ChallengeServiceImpl.java</path>
        <kind>service</kind>
        <symbol>ChallengeServiceImpl</symbol>
        <lines>19-300</lines>
        <reason>Service que llama providers - contiene lógica de fallback chain. IMPORTANTE: No modificar en esta story, solo observar cómo usa SignatureProviderPort.sendChallenge()</reason>
      </artifact>
      <artifact>
        <path>src/main/resources/application.yml</path>
        <kind>configuration</kind>
        <symbol>resilience4j.retry</symbol>
        <lines>132-137</lines>
        <reason>Actualmente tiene resilience4j.retry configurado para twilioProvider. Agregar sección resilience4j.timelimiter con 4 instances en MISMA estructura</reason>
      </artifact>
      <artifact>
        <path>pom.xml</path>
        <kind>maven-dependency</kind>
        <symbol>resilience4j</symbol>
        <lines>142-150</lines>
        <reason>Ya incluye spring-cloud-starter-circuitbreaker-resilience4j y resilience4j-micrometer. Verificar si resilience4j-timelimiter está auto-incluido o necesita agregarse explícitamente</reason>
      </artifact>
    </code>
    
    <dependencies>
      <maven>
        <dependency scope="compile" status="existing">
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
          <note>Already included from Story 2.5 - includes Retry and CircuitBreaker modules</note>
        </dependency>
        <dependency scope="compile" status="existing">
          <groupId>io.github.resilience4j</groupId>
          <artifactId>resilience4j-micrometer</artifactId>
          <note>Already included - enables Prometheus metrics for Resilience4j</note>
        </dependency>
        <dependency scope="compile" status="new">
          <groupId>io.github.resilience4j</groupId>
          <artifactId>resilience4j-timelimiter</artifactId>
          <version>managed-by-spring-cloud-bom</version>
          <note>TimeLimiter module - verificar si auto-incluido con spring-cloud-starter-circuitbreaker-resilience4j</note>
        </dependency>
        <dependency scope="compile" status="new-optional">
          <groupId>io.github.resilience4j</groupId>
          <artifactId>resilience4j-reactor</artifactId>
          <version>managed-by-spring-cloud-bom</version>
          <note>Optional - for reactive CompletableFuture support, may not be needed if TimeLimiter works with standard CompletableFuture</note>
        </dependency>
      </maven>
      <frameworks>
        <framework name="Spring Boot" version="3.2.x">
          <module>spring-boot-starter-web</module>
          <module>spring-boot-starter-actuator</module>
          <module>spring-cloud-starter-circuitbreaker-resilience4j</module>
        </framework>
        <framework name="Resilience4j" version="2.1.0">
          <module>resilience4j-retry (existing)</module>
          <module>resilience4j-circuitbreaker (existing from Epic 4)</module>
          <module>resilience4j-timelimiter (NEW for Story 3.8)</module>
          <module>resilience4j-micrometer (existing)</module>
        </framework>
        <framework name="Micrometer" version="1.12.x">
          <module>micrometer-registry-prometheus</module>
          <note>For provider.timeout.total counter export</note>
        </framework>
      </frameworks>
    </dependencies>
  </artifacts>

  <constraints>
    <!-- Architectural Constraints -->
    <constraint type="ARCHITECTURAL" id="HEXA-1" priority="CRITICAL">
      <description>SignatureProviderPort MUST remain in domain/port/outbound/ package with ZERO infrastructure dependencies</description>
      <rationale>Hexagonal architecture purity - domain ports cannot depend on infrastructure (Resilience4j annotations belong in adapter layer)</rationale>
    </constraint>
    <constraint type="ARCHITECTURAL" id="HEXA-2" priority="CRITICAL">
      <description>TimeLimiter decoration MUST happen in infrastructure layer (ChallengeServiceImpl or adapter), NOT in domain layer</description>
      <rationale>Resilience patterns are infrastructure concerns, not domain concerns</rationale>
    </constraint>
    <constraint type="ARCHITECTURAL" id="BC-1" priority="CRITICAL">
      <description>BACKWARD COMPATIBILITY: NO eliminar método sync sendChallenge(SignatureChallenge, String) de SignatureProviderPort</description>
      <rationale>Existing code (ChallengeServiceImpl) usa método sync - agregar async como NUEVO método, mantener ambos</rationale>
    </constraint>

    <!-- Implementation Constraints -->
    <constraint type="IMPLEMENTATION" id="IMPL-1" priority="HIGH">
      <description>CompletableFuture MUST use injected ScheduledExecutorService, NOT default ForkJoinPool</description>
      <rationale>Default ForkJoinPool can cause thread starvation - need dedicated thread pool with 10 threads for provider calls</rationale>
    </constraint>
    <constraint type="IMPLEMENTATION" id="IMPL-2" priority="HIGH">
      <description>Async provider methods MUST reuse existing sync logic - CompletableFuture.supplyAsync(() -> sendChallenge(challenge), executor)</description>
      <rationale>DRY principle - avoid duplicating provider call logic, async method wraps sync method</rationale>
    </constraint>
    <constraint type="IMPLEMENTATION" id="IMPL-3" priority="HIGH">
      <description>TimeLimiter instance selection MUST be dynamic based on ProviderType (SMS -> smsTimeout, PUSH -> pushTimeout, etc.)</description>
      <rationale>Each provider has different latency characteristics - SMS (1-2s) vs Push (0.5-1s) vs Voice (4-6s)</rationale>
    </constraint>
    <constraint type="IMPLEMENTATION" id="IMPL-4" priority="HIGH">
      <description>cancelRunningFuture=true MUST be configured for ALL TimeLimiter instances</description>
      <rationale>On timeout, cancel CompletableFuture to free thread and avoid thread leak</rationale>
    </constraint>

    <!-- Value Object Constraints -->
    <constraint type="VALUE-OBJECT" id="VO-1" priority="HIGH">
      <description>ProviderResult record MUST add field boolean timedOut (default false for backward compatibility)</description>
      <rationale>Epic 4 fallback logic needs to distinguish timeout failures from other failures - timeout may trigger fallback, API error may not</rationale>
    </constraint>
    <constraint type="VALUE-OBJECT" id="VO-2" priority="HIGH">
      <description>ProviderResult.timeout(String message) factory method MUST set timedOut=true, success=false, errorCode="TIMEOUT"</description>
      <rationale>Consistent timeout result creation across all provider adapters</rationale>
    </constraint>
    <constraint type="VALUE-OBJECT" id="VO-3" priority="MEDIUM">
      <description>ProviderResult compact constructor validation MUST allow timestamp=null for backward compatibility (but deprecate)</description>
      <rationale>Existing code may create ProviderResult without timestamp - validate but don't break</rationale>
    </constraint>

    <!-- Configuration Constraints -->
    <constraint type="CONFIGURATION" id="CFG-1" priority="HIGH">
      <description>application.yml MUST define resilience4j.timelimiter.configs.default with timeoutDuration and cancelRunningFuture</description>
      <rationale>Base config inherited by all instances - DRY principle</rationale>
    </constraint>
    <constraint type="CONFIGURATION" id="CFG-2" priority="HIGH">
      <description>application-local.yml MUST override with permissive timeouts (10s+) for debugging con breakpoints</description>
      <rationale>Development experience - developers need to debug without constant timeouts</rationale>
    </constraint>
    <constraint type="CONFIGURATION" id="CFG-3" priority="HIGH">
      <description>application-prod.yml MUST override with strict timeouts (3-5s) for fail-fast behavior</description>
      <rationale>Production resilience - minimize cascading failures, meet P99 < 3s NFR</rationale>
    </constraint>

    <!-- Metrics Constraints -->
    <constraint type="METRICS" id="MET-1" priority="MEDIUM">
      <description>Prometheus counter provider.timeout.total MUST have tag "provider" with values SMS|PUSH|VOICE|BIOMETRIC</description>
      <rationale>Per-provider timeout tracking for SLO monitoring and alerting</rationale>
    </constraint>
    <constraint type="METRICS" id="MET-2" priority="MEDIUM">
      <description>Timeout events MUST NOT increment provider.calls.failed counter - separate metric for timeouts</description>
      <rationale>Distinguish timeout failures from API failures - timeout may trigger retry/fallback, API error may not</rationale>
    </constraint>

    <!-- Logging Constraints -->
    <constraint type="LOGGING" id="LOG-1" priority="HIGH">
      <description>Timeout events MUST log at WARNING level (NOT ERROR) with traceId, provider, duration, challenge_id</description>
      <rationale>Timeout is EXPECTED in degraded mode - not an error, but operational warning. TraceId enables distributed tracing correlation</rationale>
    </constraint>
    <constraint type="LOGGING" id="LOG-2" priority="MEDIUM">
      <description>Timeout logs MUST NOT include stack trace (use log.warn(message, args) NOT log.warn(message, exception))</description>
      <rationale>Timeout is not exceptional - stack trace adds noise without value</rationale>
    </constraint>

    <!-- Testing Constraints -->
    <constraint type="TESTING" id="TEST-1" priority="HIGH">
      <description>Integration tests MUST use Testcontainers or mock providers (NO real external API calls)</description>
      <rationale>CI/CD pipeline cannot depend on external services (Twilio, FCM) - use mocks or containers</rationale>
    </constraint>
    <constraint type="TESTING" id="TEST-2" priority="HIGH">
      <description>Timeout integration tests MUST measure actual duration and verify ~5s (NOT 6s)</description>
      <rationale>Validate that TimeLimiter cancels CompletableFuture after configured timeout</rationale>
    </constraint>
    <constraint type="TESTING" id="TEST-3" priority="HIGH">
      <description>Unit tests MUST mock TimeLimiterRegistry and verify decorateFuture() called correctly</description>
      <rationale>Verify adapter correctly selects TimeLimiter instance and decorates async call</rationale>
    </constraint>

    <!-- Documentation Constraints -->
    <constraint type="DOCUMENTATION" id="DOC-1" priority="MEDIUM">
      <description>JavaDoc on sendChallengeAsync() MUST document that async method is preferred over sync for timeout support</description>
      <rationale>Guide developers to use async method for new code</rationale>
    </constraint>
    <constraint type="DOCUMENTATION" id="DOC-2" priority="MEDIUM">
      <description>README Provider Timeouts section MUST include timeout values table with rationale (SMS: 5s = 2.5x typical 2s)</description>
      <rationale>Operations team needs to understand timeout configuration rationale for tuning</rationale>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>SignatureProviderPort.sendChallengeAsync()</name>
      <kind>domain-port-method</kind>
      <signature>CompletableFuture&lt;ProviderResult&gt; sendChallengeAsync(SignatureChallenge challenge, String recipient)</signature>
      <path>src/main/java/com/bank/signature/domain/port/outbound/SignatureProviderPort.java</path>
      <note>NEW method to add - async version of sendChallenge() for timeout support. MUST NOT replace sync method (backward compatibility)</note>
    </interface>
    <interface>
      <name>ProviderResult record (enhanced)</name>
      <kind>value-object</kind>
      <signature>public record ProviderResult(boolean success, String providerChallengeId, String providerProof, String errorCode, String errorMessage, Instant timestamp, boolean timedOut)</signature>
      <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
      <note>Add field: boolean timedOut (defaults to false). Add factory method: static ProviderResult timeout(String message)</note>
    </interface>
    <interface>
      <name>ScheduledExecutorService Bean</name>
      <kind>spring-bean</kind>
      <signature>@Bean public ScheduledExecutorService providerExecutorService() { return new ScheduledThreadPoolExecutor(10, threadFactory); }</signature>
      <path>src/main/java/com/bank/signature/infrastructure/config/AsyncProviderConfig.java (NEW FILE)</path>
      <note>Thread pool for async provider execution - 10 threads (4 providers × 2 concurrent + 2 buffer), thread name "provider-timeout-{n}"</note>
    </interface>
    <interface>
      <name>TimeLimiterRegistry</name>
      <kind>resilience4j-registry</kind>
      <signature>TimeLimiter timeLimiter = timeLimiterRegistry.timeLimiter("smsTimeout"); CompletableFuture&lt;T&gt; future = timeLimiter.decorateFuture(() -> asyncMethod());</signature>
      <path>Inject in ChallengeServiceImpl or new SignatureProviderAdapter</path>
      <note>Resilience4j registry for timeout decoration - seleccionar instance dinámicamente por ProviderType</note>
    </interface>
    <interface>
      <name>Prometheus Counter</name>
      <kind>metrics</kind>
      <signature>meterRegistry.counter("provider.timeout.total", "provider", providerType.name()).increment()</signature>
      <path>In timeout exception handler</path>
      <note>Metrics export for timeout events - tag "provider" enables per-provider SLO tracking</note>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing framework: JUnit 5 (Jupiter). Assertion library: AssertJ. Mocking: Mockito. Integration testing: Spring Boot Test + Testcontainers. Coverage target: &gt; 85% for all new code (TimeLimiter decoration logic, async provider methods, ProviderResult enhancements). Test naming convention: methodName_whenCondition_shouldExpectedBehavior(). Test organization: src/test/java mirroring src/main/java package structure. NO real external API calls in tests (use mocks or Testcontainers).
    </standards>
    <locations>
      <location>src/test/java/com/bank/signature/infrastructure/adapter/outbound/provider/</location>
      <location>src/test/java/com/bank/signature/application/service/</location>
      <location>src/test/java/com/bank/signature/domain/model/valueobject/</location>
    </locations>
    <ideas>
      <!-- AC1: Resilience4j TimeLimiter Configuration -->
      <idea ac="AC1" test="testTimeLimiterConfiguration_shouldHaveFourInstances">
        <description>Integration test: @SpringBootTest, verify TimeLimiterRegistry contains 4 instances (smsTimeout, pushTimeout, voiceTimeout, biometricTimeout)</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC1" test="testTimeLimiterConfiguration_shouldHaveCancelRunningFutureEnabled">
        <description>Integration test: verify each TimeLimiter instance has cancelRunningFuture=true configured</description>
        <priority>MEDIUM</priority>
      </idea>

      <!-- AC2: Provider Async Methods -->
      <idea ac="AC2" test="TwilioSmsProvider.testSendChallengeAsync_shouldReturnCompletableFuture">
        <description>Unit test: verify sendChallengeAsync() returns CompletableFuture, mock Twilio client, verify future.get() returns ProviderResult</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC2" test="PushNotificationProvider.testSendChallengeAsync_shouldCompleteSuccessfully">
        <description>Unit test: mock FCM client, verify async method completes with success=true</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC2" test="VoiceCallProvider.testSendChallengeAsync_shouldReuseExistingSyncLogic">
        <description>Unit test: verify async method delegates to sync sendChallenge() - NO logic duplication</description>
        <priority>MEDIUM</priority>
      </idea>
      <idea ac="AC2" test="BiometricProvider.testSendChallengeAsync_shouldReturnCompletedFuture">
        <description>Unit test: verify stub returns CompletableFuture.completedFuture() (instant completion)</description>
        <priority>LOW</priority>
      </idea>

      <!-- AC3: TimeLimiter Decoration -->
      <idea ac="AC3" test="testSendChallenge_whenProviderTimesOut_shouldReturnFailure">
        <description>Unit test: mock provider async method que no completa nunca, mock TimeLimiter.decorateFuture() lanza TimeoutException, verify ProviderResult.failure("TIMEOUT")</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC3" test="testTimeLimiterSelection_shouldSelectCorrectInstanceByProviderType">
        <description>Unit test: verify SMS → smsTimeout, PUSH → pushTimeout, VOICE → voiceTimeout, BIOMETRIC → biometricTimeout mapping</description>
        <priority>HIGH</priority>
      </idea>

      <!-- AC4: Cancel Running Future -->
      <idea ac="AC4" test="testCancelRunningFuture_whenTimeout_shouldCancelFuture">
        <description>Integration test: verify CompletableFuture.isCancelled()=true after timeout</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC4" test="testScheduledExecutorService_shouldHave10Threads">
        <description>Unit test: verify bean ScheduledExecutorService configured with corePoolSize=10</description>
        <priority>MEDIUM</priority>
      </idea>

      <!-- AC5: Prometheus Metrics -->
      <idea ac="AC5" test="testTimeoutMetrics_shouldIncrementCounter">
        <description>Unit test: mock timeout event, verify meterRegistry.counter("provider.timeout.total", "provider", "SMS").increment() called</description>
        <priority>MEDIUM</priority>
      </idea>
      <idea ac="AC5" test="testTimeoutMetrics_shouldBeExportedToPrometheus">
        <description>Integration test: trigger timeout, GET /actuator/prometheus, verify provider_timeout_total{provider="SMS"} present</description>
        <priority>MEDIUM</priority>
      </idea>

      <!-- AC7: Integration Test Slow Provider -->
      <idea ac="AC7" test="testProviderTimeout_shouldReturnFailureAfter5Seconds">
        <description>Integration test: mock provider sleep(6000ms), call adapter.sendChallenge(), measure duration (debe ser ~5s NO 6s), verify ProviderResult.timedOut=true, errorCode="TIMEOUT"</description>
        <priority>HIGH</priority>
      </idea>

      <!-- AC8: Unit Tests SignatureProviderAdapter -->
      <idea ac="AC8" test="testSendChallenge_whenProviderRespondsInTime_shouldReturnSuccess">
        <description>Unit test: mock provider completa en 1s (timeout 5s), verify ProviderResult.success=true</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC8" test="testAsyncExecution_whenTimeoutExceeded_shouldCancelFuture">
        <description>Unit test: verify CompletableFuture cancelled after timeout</description>
        <priority>HIGH</priority>
      </idea>

      <!-- AC9: Multi-Environment Config -->
      <idea ac="AC9" test="testLocalProfile_shouldUsePermissiveTimeouts">
        <description>Integration test: @ActiveProfiles("local"), verify TimeLimiter smsTimeout has timeoutDuration=10s (from application-local.yml)</description>
        <priority>MEDIUM</priority>
      </idea>
      <idea ac="AC9" test="testProdProfile_shouldUseStrictTimeouts">
        <description>Integration test: @ActiveProfiles("prod"), verify smsTimeout has timeoutDuration=4s (from application-prod.yml)</description>
        <priority>MEDIUM</priority>
      </idea>

      <!-- AC10: ProviderResult timedOut Field -->
      <idea ac="AC10" test="testProviderResult_timeoutFactory_shouldSetTimedOutTrue">
        <description>Unit test: verify ProviderResult.timeout("message") returns record with timedOut=true, success=false, errorCode="TIMEOUT"</description>
        <priority>HIGH</priority>
      </idea>
      <idea ac="AC10" test="testProviderResult_successFactory_shouldSetTimedOutFalse">
        <description>Unit test: verify ProviderResult.success() returns record with timedOut=false</description>
        <priority>MEDIUM</priority>
      </idea>

      <!-- AC11: Timeout Logging -->
      <idea ac="AC11" test="testTimeoutLogging_shouldLogWarningWithTraceId">
        <description>Unit test: mock timeout event, verify log.warn() called (NOT log.error()), verify MDC traceId included, verify NO stack trace logged</description>
        <priority>MEDIUM</priority>
      </idea>
    </ideas>
  </tests>
</story-context>
