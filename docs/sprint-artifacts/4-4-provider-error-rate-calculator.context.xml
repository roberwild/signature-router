<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>4</storyId>
    <title>Provider Error Rate Calculator</title>
    <status>drafted</status>
    <generatedAt>2025-11-28</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/4-4-provider-error-rate-calculator.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Sistema</asA>
    <iWant>Calcular error rate por provider en ventana deslizante usando métricas Prometheus</iWant>
    <soThat>El circuit breaker puede tomar decisiones basadas en error rate real (>50% → OPEN)</soThat>
    <tasks>
      <task id="1" estimated="1.5h">
        <title>Enhance ProviderErrorRateCalculator</title>
        <subtasks>
          <subtask>Revisar implementación existente en ProviderErrorRateCalculator.java (creada en Story 3.10)</subtask>
          <subtask>Inyectar MeterRegistry para consultar métricas Prometheus</subtask>
          <subtask>Method: calculateErrorRate(String provider) retorna double (0.0-1.0)</subtask>
          <subtask>Query MeterRegistry para obtener success/failure counts en 1min window</subtask>
          <subtask>Implementar formula: errorRate = failures / (successes + failures)</subtask>
          <subtask>Manejar edge cases: sin datos → 0.0, división por cero → 0.0</subtask>
          <subtask>Actualizar provider.error.rate gauge vía ProviderMetrics.updateErrorRate()</subtask>
          <subtask>Log warning si error rate > threshold (50%)</subtask>
        </subtasks>
      </task>
      <task id="2" estimated="30min">
        <title>Create ProviderErrorRateExceeded Event</title>
        <subtasks>
          <subtask>Crear domain event: ProviderErrorRateExceeded</subtask>
          <subtask>Fields: provider (String), errorRate (double), threshold (double), timestamp (Instant)</subtask>
          <subtask>Publisher: ApplicationEventPublisher desde ProviderErrorRateCalculator</subtask>
          <subtask>Publicar evento cuando error rate > threshold por 30s consecutivos</subtask>
        </subtasks>
      </task>
      <task id="3" estimated="1h">
        <title>Integrate with DegradedModeManager</title>
        <subtasks>
          <subtask>DegradedModeManager escucha evento ProviderErrorRateExceeded (@EventListener)</subtask>
          <subtask>Cuando evento recibido: activar degraded mode para provider afectado</subtask>
          <subtask>Duration: 5 minutos (configurable en application.yml)</subtask>
          <subtask>Log: "Provider {provider} error rate {errorRate}% exceeds threshold, activating degraded mode"</subtask>
          <subtask>Métricas: increment degraded.mode.activations.total{provider, reason="error_rate"}</subtask>
        </subtasks>
      </task>
      <task id="4" estimated="30min">
        <title>Circuit Breaker Configuration</title>
        <subtasks>
          <subtask>Verify Resilience4j circuit breaker config en application.yml</subtask>
          <subtask>Ensure failure-rate-threshold: 50 configurado por provider</subtask>
          <subtask>Ensure sliding-window-type: COUNT_BASED y sliding-window-size: 100</subtask>
          <subtask>Document relación entre error rate gauge y circuit breaker threshold</subtask>
        </subtasks>
      </task>
      <task id="5" estimated="45min">
        <title>Health Endpoint Integration</title>
        <subtasks>
          <subtask>Crear ProviderHealthIndicator que lee error rate actual</subtask>
          <subtask>Health status logic: error_rate &lt; 25% → UP, 25-50% → WARNING, >= 50% → DOWN</subtask>
          <subtask>Include error rate en health response: { "provider": "SMS", "errorRate": 0.15, "status": "UP" }</subtask>
          <subtask>Endpoint: GET /actuator/health/providers</subtask>
        </subtasks>
      </task>
      <task id="6" estimated="1.5h">
        <title>Unit Tests</title>
        <subtasks>
          <subtask>Test: shouldCalculateZeroErrorRateWhenNoCalls()</subtask>
          <subtask>Test: shouldCalculate100PercentErrorRateWhenAllFailed()</subtask>
          <subtask>Test: shouldCalculateZeroErrorRateWhenAllSucceeded()</subtask>
          <subtask>Test: shouldCalculateMixedErrorRate() (60% failures → 0.6)</subtask>
          <subtask>Test: shouldPublishEventWhenErrorRateExceedsThreshold()</subtask>
          <subtask>Test: shouldNotPublishEventWhenBelowThreshold()</subtask>
          <subtask>Test: shouldUpdatePrometheusGauge()</subtask>
          <subtask>Mock MeterRegistry y ProviderMetrics</subtask>
        </subtasks>
      </task>
      <task id="7" estimated="1h">
        <title>Integration Test</title>
        <subtasks>
          <subtask>Test: simular 60 provider failures de 100 llamadas</subtask>
          <subtask>Verificar que error rate gauge = 0.6</subtask>
          <subtask>Verificar que evento ProviderErrorRateExceeded fue publicado</subtask>
          <subtask>Verificar que DegradedModeManager activó degraded mode</subtask>
          <subtask>Verificar que circuit breaker transicionó a OPEN</subtask>
        </subtasks>
      </task>
      <task id="8" estimated="30min">
        <title>Update Documentation</title>
        <subtasks>
          <subtask>README.md: section "Error Rate Calculation"</subtask>
          <subtask>Explain 1-minute sliding window strategy</subtask>
          <subtask>Document error rate thresholds (50% circuit breaker)</subtask>
          <subtask>CHANGELOG.md: Story 4.4 entry</subtask>
          <subtask>Grafana dashboard spec: panel para error rate trending</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">ProviderErrorRateCalculator scheduled task ejecuta cada 10 segundos (@Scheduled(fixedDelay = 10000))</criterion>
    <criterion id="AC2">Calcula error rate por provider usando formula: errorRate = failures / (successes + failures) en ventana de 1 minuto</criterion>
    <criterion id="AC3">Error rate expuesto como Prometheus gauge: provider.error.rate{provider="SMS|PUSH|VOICE|BIOMETRIC"}</criterion>
    <criterion id="AC4">Si error rate > 50% por 30 segundos: dispara evento ProviderErrorRateExceeded</criterion>
    <criterion id="AC5">Edge cases manejados: sin llamadas → errorRate = 0.0, todas fallaron → errorRate = 1.0, todas exitosas → errorRate = 0.0</criterion>
    <criterion id="AC6">ProviderErrorRateCalculator consulta métricas desde MeterRegistry: successCount y failureCount en 1min window</criterion>
    <criterion id="AC7">Error rate actualizado en ProviderMetrics.updateErrorRate(provider, errorRate)</criterion>
    <criterion id="AC8">Health endpoint /actuator/health/providers incluye error rate actual por provider</criterion>
    <criterion id="AC9">Circuit breaker configuration lee error rate threshold desde application.yml: resilience4j.circuitbreaker.instances.&lt;provider&gt;.failure-rate-threshold: 50</criterion>
    <criterion id="AC10">Cuando error rate > threshold por duration configurado → circuit breaker transiciona a OPEN</criterion>
    <criterion id="AC11">DegradedModeManager escucha eventos ProviderErrorRateExceeded y activa degraded mode</criterion>
    <criterion id="AC12">Unit tests validan cálculo correcto en diferentes escenarios (0 calls, all success, all failures, mixed)</criterion>
    <criterion id="AC13">Integration test simula provider failures y valida que circuit breaker OPEN se activa cuando error rate > 50%</criterion>
    <criterion id="AC14">Documentation en README explica error rate calculation y thresholds</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>FR Group 4: Fallback & Resilience</section>
        <snippet>FR33: Calcular error rate por provider. FR34: Activar circuit breaker >50% error rate. FR36: Reactivar provider automáticamente.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/06-resilience-strategy.md</path>
        <title>Resilience Strategy - Patterns & Configuration</title>
        <section>8. Degraded Mode Management - 8.2 Provider Health Monitoring</section>
        <snippet>Error rate calculation: checkProviderHealth() runs every 1 minute. Formula: errorRate = (failedCount * 100.0) / recentChallenges.size(). Circuit breaker threshold: 50% triggers degraded mode for 5 minutes.</snippet>
      </doc>
      <doc>
        <path>docs/architecture/06-resilience-strategy.md</path>
        <title>Resilience Strategy</title>
        <section>3. Circuit Breaker Pattern - 3.1 Configuration</section>
        <snippet>failure-rate-threshold: 50 (Open if >50% fail), slidingWindowType: COUNT_BASED, slidingWindowSize: 100, minimumNumberOfCalls: 10, waitDurationInOpenState: 30s.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 4: Resilience & Circuit Breaking</section>
        <snippet>Sistema maneja fallos gracefully con degraded mode. FR29-FR38, NFR-A4-A7. 8 stories total. Story 4.4: Provider Error Rate Calculator integrates with circuit breaker decisions.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/3-10-provider-metrics-tracking.md</path>
        <title>Story 3.10: Provider Metrics Tracking</title>
        <section>Dev Notes - ProviderErrorRateCalculator Skeleton</section>
        <snippet>ProviderErrorRateCalculator skeleton created with @Scheduled(fixedDelay = 10000). Formula documented: errorRate = failureCount / (successCount + failureCount). JavaDoc mentions Story 4.4 will complete implementation.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/4-3-degraded-mode-manager.md</path>
        <title>Story 4.3: Degraded Mode Manager</title>
        <section>Dev Notes</section>
        <snippet>DegradedModeManager service created. Handles event-driven activation. Method: activateDegradedMode(provider, duration). Admin API: POST /api/v1/admin/providers/{provider}/degraded-mode. Metrics: degraded.mode.activations.total counter available.</snippet>
      </doc>
      <doc>
        <path>docs/development/provider-metrics-alerts.yml</path>
        <title>Provider Metrics Alert Rules</title>
        <section>ProviderHighErrorRate Alert</section>
        <snippet>Alert: ProviderHighErrorRate fires when provider error rate > 5% for 5 minutes. Uses sum(rate(provider_calls_total{status="failure"}[1m])) / sum(rate(provider_calls_total[1m])).</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/observability/metrics/ProviderErrorRateCalculator.java</path>
        <kind>service</kind>
        <symbol>ProviderErrorRateCalculator</symbol>
        <lines>1-123</lines>
        <reason>Skeleton implementation created in Story 3.10. Needs enhancement: add event publishing, threshold checking, integration with DegradedModeManager.</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/observability/metrics/ProviderMetrics.java</path>
        <kind>service</kind>
        <symbol>ProviderMetrics.updateErrorRate()</symbol>
        <lines>160-167</lines>
        <reason>Method to update provider.error.rate Prometheus gauge. Already implemented and ready to use.</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/resilience/DegradedModeManager.java</path>
        <kind>service</kind>
        <symbol>DegradedModeManager</symbol>
        <lines>1-371</lines>
        <reason>Manages degraded mode state. Needs @EventListener method to react to ProviderErrorRateExceeded events. Method activateDegradedMode() already exists.</reason>
      </artifact>
      <artifact>
        <path>src/main/java/com/bank/signature/infrastructure/health/DegradedModeHealthIndicator.java</path>
        <kind>health-indicator</kind>
        <symbol>DegradedModeHealthIndicator</symbol>
        <lines>10-91</lines>
        <reason>Existing health indicator for degraded mode. Can be used as reference for creating ProviderHealthIndicator with error rate display.</reason>
      </artifact>
      <artifact>
        <path>src/main/resources/application.yml</path>
        <kind>configuration</kind>
        <symbol>resilience4j.circuitbreaker</symbol>
        <lines>212-243</lines>
        <reason>Circuit breaker configuration with failure-rate-threshold: 50 for all providers. Story 4.4 documents relationship between error rate gauge and these thresholds.</reason>
      </artifact>
      <artifact>
        <path>src/main/resources/application.yml</path>
        <kind>configuration</kind>
        <symbol>degraded-mode</symbol>
        <lines>245-252</lines>
        <reason>Degraded mode configuration: error-rate-threshold: 80, recovery-threshold: 50. Story 4.4 uses 50% threshold for ProviderErrorRateExceeded event.</reason>
      </artifact>
      <artifact>
        <path>src/test/java/com/bank/signature/infrastructure/observability/metrics/ProviderMetricsTest.java</path>
        <kind>test</kind>
        <symbol>ProviderMetricsTest</symbol>
        <lines>1-173</lines>
        <reason>Existing unit tests for ProviderMetrics component. Reference for testing patterns (mocking MeterRegistry, asserting gauge values).</reason>
      </artifact>
      <artifact>
        <path>src/test/java/com/bank/signature/infrastructure/observability/metrics/ProviderMetricsIntegrationTest.java</path>
        <kind>test</kind>
        <symbol>testErrorRateMetric()</symbol>
        <lines>73-122</lines>
        <reason>Integration test demonstrating error rate calculation from counters. Shows pattern: query counters, calculate errorRate, update gauge, assert value.</reason>
      </artifact>
      <artifact>
        <path>src/test/java/com/bank/signature/infrastructure/resilience/DegradedModeManagerTest.java</path>
        <kind>test</kind>
        <symbol>DegradedModeManagerTest</symbol>
        <lines>83-126</lines>
        <reason>Unit tests for DegradedModeManager. Reference for testing event-driven degraded mode activation patterns.</reason>
      </artifact>
    </code>
    <dependencies>
      <framework name="Spring Boot" version="3.2.0">
        <package>spring-boot-starter-web</package>
        <package>spring-boot-starter-data-jpa</package>
        <package>spring-boot-starter-actuator</package>
        <package>spring-boot-starter-security</package>
      </framework>
      <framework name="Resilience4j" version="included via spring-boot-starter">
        <package>resilience4j-retry</package>
        <package>resilience4j-timelimiter</package>
        <package>resilience4j-circuitbreaker</package>
      </framework>
      <framework name="Micrometer" version="included via actuator">
        <package>micrometer-core</package>
        <package>micrometer-registry-prometheus</package>
      </framework>
      <framework name="Testing">
        <package>spring-boot-starter-test</package>
        <package>testcontainers (1.19.3)</package>
        <package>archunit (1.1.0)</package>
      </framework>
      <database>PostgreSQL 15 with Liquibase migrations</database>
      <messaging>Apache Kafka with Avro Schema Registry</messaging>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Use Hexagonal Architecture pattern: domain events in domain layer, infrastructure adapters for external systems</constraint>
    <constraint>Domain events should be published via ApplicationEventPublisher (Spring Events), not directly to Kafka</constraint>
    <constraint>Metrics must use Micrometer MeterRegistry API, not Prometheus client directly</constraint>
    <constraint>Error rate calculation window: 1 minute (responsive but not noisy)</constraint>
    <constraint>Error rate threshold for event publishing: 50% (align with circuit breaker failure-rate-threshold)</constraint>
    <constraint>Scheduled task execution: fixedDelay = 10000ms (10 seconds) for real-time monitoring</constraint>
    <constraint>Edge case handling: totalCalls == 0 → errorRate = 0.0 (assume healthy until proven otherwise)</constraint>
    <constraint>Logging: INFO level for error rate > 5%, DEBUG for lower values to avoid log noise</constraint>
    <constraint>Health endpoint should return UP even when providers degraded (system still functional, graceful degradation)</constraint>
    <constraint>Testing: minimum 85% code coverage, integration tests required for circuit breaker state transitions</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>ProviderMetrics.updateErrorRate</name>
      <kind>Java method</kind>
      <signature>public void updateErrorRate(String provider, double errorRate)</signature>
      <path>src/main/java/com/bank/signature/infrastructure/observability/metrics/ProviderMetrics.java</path>
      <description>Updates provider.error.rate Prometheus gauge. Call after calculating error rate.</description>
    </interface>
    <interface>
      <name>DegradedModeManager.activateDegradedMode</name>
      <kind>Java method</kind>
      <signature>public void activateDegradedMode(String provider, Duration pauseDuration)</signature>
      <path>src/main/java/com/bank/signature/infrastructure/resilience/DegradedModeManager.java</path>
      <description>Activates degraded mode for specific provider. Call from @EventListener when ProviderErrorRateExceeded event received.</description>
    </interface>
    <interface>
      <name>ApplicationEventPublisher.publishEvent</name>
      <kind>Spring Framework interface</kind>
      <signature>void publishEvent(Object event)</signature>
      <path>org.springframework.context.ApplicationEventPublisher</path>
      <description>Publish ProviderErrorRateExceeded domain event. Inject ApplicationEventPublisher into ProviderErrorRateCalculator.</description>
    </interface>
    <interface>
      <name>MeterRegistry.find</name>
      <kind>Micrometer API</kind>
      <signature>Search find(String name).tag(String key, String value).counter()</signature>
      <path>io.micrometer.core.instrument.MeterRegistry</path>
      <description>Query Prometheus counters. Use: meterRegistry.find("provider.calls.total").tag("provider", "SMS").tag("status", "success").counter().count()</description>
    </interface>
    <interface>
      <name>Health Actuator Endpoint</name>
      <kind>REST API</kind>
      <signature>GET /actuator/health/providers</signature>
      <path>Spring Boot Actuator</path>
      <description>Provider health check endpoint. Implement ProviderHealthIndicator extends HealthIndicator to expose error rate in response.</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
      - Use JUnit 5 (@Test, @DisplayName, @ParameterizedTest)
      - Unit tests: Mock dependencies with Mockito (@Mock, @InjectMocks)
      - Integration tests: Use @SpringBootTest with TestContainers for PostgreSQL/Kafka
      - Assert with AssertJ (assertThat(), isCloseTo() for double comparisons)
      - Arrange-Act-Assert pattern in all tests
      - Test class naming: {ClassName}Test for unit, {ClassName}IntegrationTest for integration
      - Minimum 85% code coverage target
      - Use @DataJpaTest for repository tests, @WebMvcTest for controller tests
    </standards>
    <locations>
      <location>src/test/java/com/bank/signature/infrastructure/observability/metrics/</location>
      <location>src/test/java/com/bank/signature/infrastructure/resilience/</location>
      <location>src/test/java/com/bank/signature/infrastructure/health/</location>
    </locations>
    <ideas>
      <test-idea criterion="AC1,AC2,AC6">
        Unit test: shouldCalculateErrorRateEvery10Seconds()
        - Mock MeterRegistry to return specific success/failure counts
        - Verify calculateErrorRates() method queries counters with correct tags
        - Assert errorRate = failureCount / (successCount + failureCount)
      </test-idea>
      <test-idea criterion="AC3,AC7">
        Unit test: shouldUpdatePrometheusGaugeWithCalculatedErrorRate()
        - Calculate error rate (e.g., 60 failures, 40 successes → 0.6)
        - Verify ProviderMetrics.updateErrorRate() called with provider="SMS", errorRate=0.6
        - Assert gauge value matches expected
      </test-idea>
      <test-idea criterion="AC4,AC11">
        Unit test: shouldPublishEventWhenErrorRateExceedsThreshold()
        - Mock error rate calculation returns 0.65 (65%)
        - Verify ApplicationEventPublisher.publishEvent() called with ProviderErrorRateExceeded event
        - Assert event fields: provider, errorRate, threshold, timestamp
      </test-idea>
      <test-idea criterion="AC5">
        Unit test: shouldHandleEdgeCasesCorrectly()
        - Test 1: successCount=0, failureCount=0 → errorRate=0.0
        - Test 2: successCount=0, failureCount=100 → errorRate=1.0
        - Test 3: successCount=100, failureCount=0 → errorRate=0.0
        - Test 4: successCount=40, failureCount=60 → errorRate=0.6
      </test-idea>
      <test-idea criterion="AC8">
        Integration test: shouldIncludeErrorRateInHealthEndpoint()
        - Trigger provider calls with known success/failure ratio
        - GET /actuator/health/providers
        - Assert response includes errorRate field per provider
        - Assert health status based on error rate (UP/WARNING/DOWN)
      </test-idea>
      <test-idea criterion="AC10,AC13">
        Integration test: shouldOpenCircuitBreakerWhenErrorRateExceeds50Percent()
        - Simulate 60 provider failures out of 100 calls
        - Wait for error rate calculation (10s + processing)
        - Verify circuit breaker state = OPEN
        - Verify DegradedModeManager activated degraded mode
      </test-idea>
      <test-idea criterion="AC12">
        Unit test: shouldNotPublishEventWhenErrorRateBelowThreshold()
        - Mock error rate calculation returns 0.30 (30%)
        - Verify ApplicationEventPublisher.publishEvent() NOT called
        - Verify no degraded mode activation
      </test-idea>
    </ideas>
  </tests>
</story-context>
