<?xml version="1.0" encoding="UTF-8"?>
<!-- 
  Story Context: 3.1 - Provider Abstraction Interface
  Generated: 2025-11-27
  Epic: 3 - Multi-Provider Integration
  
  This context file provides comprehensive technical guidance for implementing
  the provider abstraction layer in the domain layer, following hexagonal architecture principles.
-->
<story-context>
  <metadata>
    <story-id>3.1</story-id>
    <story-key>3-1-provider-abstraction-interface</story-key>
    <epic-id>3</epic-id>
    <title>Provider Abstraction Interface</title>
    <status>drafted</status>
    <generated-date>2025-11-27</generated-date>
  </metadata>

  <story>
    <as-a>Developer</as-a>
    <i-want>Una interfaz domain para enviar challenges a providers externos</i-want>
    <so-that>El dominio permanezca puro y los providers sean intercambiables</so-that>

    <business-value>
      Establece la capa de abstracción hexagonal entre el domain layer y los providers externos
      (Twilio, Firebase, etc.), permitiendo:
      - Hexagonal Architecture: Domain purity (ZERO dependencies en infraestructura)
      - Testability: Domain logic testeable sin providers reales
      - Flexibility: Cambiar/agregar providers sin tocar domain logic
      - Maintainability: Separation of Concerns clara
    </business-value>
  </story>

  <acceptance-criteria>
    <criterion id="AC1">
      SignatureProviderPort interface definida en domain/port/outbound package
    </criterion>
    <criterion id="AC2">
      Interface tiene método sendChallenge(SignatureChallenge): ProviderResult
    </criterion>
    <criterion id="AC3">
      Interface tiene método checkHealth(ProviderType): HealthStatus
    </criterion>
    <criterion id="AC4">
      ProviderResult value object (Java 21 record) con campos: success, providerChallengeId,
      providerProof, errorCode, errorMessage, timestamp
    </criterion>
    <criterion id="AC5">
      ProviderResult tiene factory methods: success(String, String) y failure(String, String)
    </criterion>
    <criterion id="AC6">
      ProviderType enum definido con valores: SMS, PUSH, VOICE, BIOMETRIC
    </criterion>
    <criterion id="AC7">
      HealthStatus value object (record) con campos: status (UP/DOWN), details, timestamp
    </criterion>
    <criterion id="AC8">
      Domain port interface tiene ZERO dependencies en infrastructure (NO Twilio, NO FCM, NO HTTP
      clients)
    </criterion>
    <criterion id="AC9">
      ArchUnit test valida domain purity (port interface no depende de infrastructure packages)
    </criterion>
    <criterion id="AC10">
      Unit tests para ProviderResult factory methods (success/failure scenarios)
    </criterion>
    <criterion id="AC11">
      Unit tests para ProviderType enum (valores correctos, toString)
    </criterion>
    <criterion id="AC12">
      JavaDoc completo en SignatureProviderPort (con ejemplos de uso)
    </criterion>
  </acceptance-criteria>

  <tasks>
    <task id="1" estimated="1h">
      <name>Provider Abstraction Domain Port Interface</name>
      <subtasks>
        <subtask>Crear interface SignatureProviderPort en com.bank.signature.domain.port.outbound</subtask>
        <subtask>Definir método ProviderResult sendChallenge(SignatureChallenge challenge)</subtask>
        <subtask>Definir método HealthStatus checkHealth(ProviderType providerType)</subtask>
        <subtask>Agregar JavaDoc completo con ejemplos de uso</subtask>
        <subtask>Verificar ZERO imports de infrastructure packages</subtask>
      </subtasks>
      <files-to-create>
        <file>src/main/java/com/bank/signature/domain/port/outbound/SignatureProviderPort.java</file>
      </files-to-create>
    </task>

    <task id="2" estimated="1h">
      <name>ProviderResult Value Object</name>
      <subtasks>
        <subtask>Crear record ProviderResult en com.bank.signature.domain.model.valueobject</subtask>
        <subtask>Definir 6 campos: success, providerChallengeId, providerProof, errorCode,
          errorMessage, timestamp</subtask>
        <subtask>Implementar compact constructor con validaciones</subtask>
        <subtask>Implementar factory method success(String challengeId, String proof)</subtask>
        <subtask>Implementar factory method failure(String errorCode, String errorMessage)</subtask>
        <subtask>Agregar JavaDoc con ejemplos</subtask>
      </subtasks>
      <files-to-create>
        <file>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</file>
      </files-to-create>
    </task>

    <task id="3" estimated="30min">
      <name>ProviderType Enum</name>
      <subtasks>
        <subtask>Crear enum ProviderType en com.bank.signature.domain.model.valueobject</subtask>
        <subtask>Definir valores: SMS, PUSH, VOICE, BIOMETRIC</subtask>
        <subtask>Agregar campo displayName por valor</subtask>
        <subtask>Agregar método getDisplayName()</subtask>
        <subtask>JavaDoc describiendo cada tipo</subtask>
      </subtasks>
      <files-to-create>
        <file>src/main/java/com/bank/signature/domain/model/valueobject/ProviderType.java</file>
      </files-to-create>
    </task>

    <task id="4" estimated="30min">
      <name>HealthStatus Value Object</name>
      <subtasks>
        <subtask>Crear record HealthStatus en com.bank.signature.domain.model.valueobject</subtask>
        <subtask>Definir campos: Status status (enum UP/DOWN), String details, Instant timestamp</subtask>
        <subtask>Crear enum interno Status con valores UP, DOWN</subtask>
        <subtask>Implementar factory methods: UP(String details), DOWN(String details)</subtask>
        <subtask>Compact constructor: timestamp default Instant.now() si null</subtask>
      </subtasks>
      <files-to-create>
        <file>src/main/java/com/bank/signature/domain/model/valueobject/HealthStatus.java</file>
      </files-to-create>
    </task>

    <task id="5" estimated="30min">
      <name>ChannelType to ProviderType Mapping</name>
      <subtasks>
        <subtask>Abrir enum ChannelType existente</subtask>
        <subtask>Agregar método toProviderType() → ProviderType</subtask>
        <subtask>Implementar mapping para SMS, PUSH, VOICE, BIOMETRIC</subtask>
        <subtask>Actualizar JavaDoc</subtask>
        <subtask>Unit test para mapping (4 scenarios)</subtask>
      </subtasks>
      <files-to-modify>
        <file>src/main/java/com/bank/signature/domain/model/valueobject/ChannelType.java</file>
      </files-to-modify>
    </task>

    <task id="6" estimated="45min">
      <name>ArchUnit Domain Purity Test</name>
      <subtasks>
        <subtask>Abrir HexagonalArchitectureTest.java existente</subtask>
        <subtask>Agregar test method domainPortsShouldNotDependOnInfrastructure()</subtask>
        <subtask>Validar: classes en ..domain.port.outbound.. NO dependen de ..infrastructure..</subtask>
        <subtask>Validar: NO dependencies en Twilio/FCM/HTTP external libs</subtask>
        <subtask>Ejecutar test → debe PASS</subtask>
      </subtasks>
      <files-to-modify>
        <file>src/test/java/com/bank/signature/architecture/HexagonalArchitectureTest.java</file>
      </files-to-modify>
    </task>

    <task id="7-9" estimated="2h">
      <name>Unit Tests (ProviderResult, ProviderType, HealthStatus)</name>
      <files-to-create>
        <file>src/test/java/com/bank/signature/domain/model/valueobject/ProviderResultTest.java</file>
        <file>src/test/java/com/bank/signature/domain/model/valueobject/ProviderTypeTest.java</file>
        <file>src/test/java/com/bank/signature/domain/model/valueobject/HealthStatusTest.java</file>
      </files-to-create>
      <test-count>12+ test methods total</test-count>
      <coverage-target>&gt; 90%</coverage-target>
    </task>

    <task id="10-12" estimated="1.5h">
      <name>Documentation and Integration Verification</name>
      <files-to-modify>
        <file>README.md</file>
        <file>CHANGELOG.md</file>
      </files-to-modify>
    </task>
  </tasks>

  <artifacts>
    <docs>
      <artifact>
        <path>docs/sprint-artifacts/tech-spec-epic-3.md</path>
        <title>Epic 3 Technical Specification</title>
        <section>Provider Abstraction (Section 1)</section>
        <snippet>
          Outbound port for sending signature challenges via external providers.
          SignatureProviderPort interface with sendChallenge() and checkHealth() methods.
          ProviderResult record with success, providerChallengeId, providerProof, errorCode,
          errorMessage, timestamp.
          ProviderType enum: SMS, PUSH, VOICE, BIOMETRIC.
          HealthStatus record: status (UP/DOWN), details, timestamp.
        </snippet>
      </artifact>

      <artifact>
        <path>docs/architecture/02-hexagonal-structure.md</path>
        <title>Hexagonal Architecture - Package Structure</title>
        <section>Domain Layer - Ports</section>
        <snippet>
          domain/port/outbound/ contains driven ports (dependencies).
          SignatureProviderPort is outbound port for external provider integrations.
          Domain layer MUST be pure - NO infrastructure dependencies.
          Implementations in infrastructure/adapter/outbound/.
        </snippet>
      </artifact>

      <artifact>
        <path>docs/prd.md</path>
        <title>Product Requirements Document</title>
        <section>FR20-FR28: Challenge Delivery</section>
        <snippet>
          FR20: Sistema envía challenges SMS vía Twilio.
          FR21: Sistema envía push notifications.
          FR22: Sistema realiza llamadas de voz.
          FR23: Almacenar provider_challenge_id para correlación.
          FR24: Almacenar provider_proof (non-repudiation).
          FR25: Aplicar timeouts configurables.
        </snippet>
      </artifact>

      <artifact>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 3: Multi-Provider Integration</section>
        <snippet>
          Story 3.1: Provider Abstraction Interface - Establece capa hexagonal entre domain y
          providers.
          Prerequisite para Stories 3.2-3.10 (Twilio, FCM, Voice, Biometric implementations).
        </snippet>
      </artifact>
    </docs>

    <code>
      <artifact>
        <path>src/main/java/com/bank/signature/domain/model/valueobject/ChannelType.java</path>
        <kind>enum</kind>
        <symbol>ChannelType</symbol>
        <lines>1-23</lines>
        <reason>
          Existing enum con valores SMS, PUSH, VOICE, BIOMETRIC.
          TASK 5: Agregar método toProviderType() para mapping a ProviderType.
        </reason>
        <content><![CDATA[
package com.bank.signature.domain.model.valueobject;

/**
 * Signature challenge delivery channel types.
 * 
 * @since Story 1.5
 */
public enum ChannelType {
    /** SMS channel (OTP via text message). */
    SMS,
    
    /** Push notification channel (mobile app). */
    PUSH,
    
    /** Voice call channel (IVR system). */
    VOICE,
    
    /** Biometric channel (fingerprint, face recognition). */
    BIOMETRIC
}
        ]]></content>
      </artifact>

      <artifact>
        <path>src/main/java/com/bank/signature/domain/model/valueobject/Money.java</path>
        <kind>record</kind>
        <symbol>Money</symbol>
        <lines>1-40</lines>
        <reason>
          Example de Java 21 record pattern con compact constructor validation y factory methods.
          TEMPLATE para ProviderResult y HealthStatus records.
        </reason>
        <content><![CDATA[
public record Money(BigDecimal amount, String currency) {
    
    /**
     * Compact constructor with validation.
     */
    public Money {
        if (amount == null) {
            throw new IllegalArgumentException("Amount cannot be null");
        }
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Amount must be >= 0, got: " + amount);
        }
        if (currency == null || currency.isBlank()) {
            throw new IllegalArgumentException("Currency cannot be null or empty");
        }
    }
    
    /**
     * Add another Money amount.
     */
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }
}
        ]]></content>
      </artifact>

      <artifact>
        <path>src/test/java/com/bank/signature/architecture/HexagonalArchitectureTest.java</path>
        <kind>test</kind>
        <symbol>HexagonalArchitectureTest</symbol>
        <reason>
          Existing ArchUnit test class.
          TASK 6: Agregar test method domainPortsShouldNotDependOnInfrastructure().
        </reason>
      </artifact>

      <artifact>
        <path>src/main/java/com/bank/signature/domain/model/entity/SignatureChallenge.java</path>
        <kind>entity</kind>
        <symbol>SignatureChallenge</symbol>
        <reason>
          SignatureChallenge entity - parámetro para SignatureProviderPort.sendChallenge().
          Tiene campos: recipient, message, channelType usados por providers.
        </reason>
      </artifact>
    </code>

    <dependencies>
      <maven>
        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter</artifactId>
          <note>Already included - base Spring Boot</note>
        </dependency>
        <dependency>
          <groupId>org.projectlombok</groupId>
          <artifactId>lombok</artifactId>
          <note>Already included - NOT used for domain value objects (prefer records)</note>
        </dependency>
        <dependency>
          <groupId>com.tngtech.archunit</groupId>
          <artifactId>archunit-junit5</artifactId>
          <scope>test</scope>
          <note>Already included - for ArchUnit domain purity tests</note>
        </dependency>
        <dependency>
          <groupId>org.junit.jupiter</groupId>
          <artifactId>junit-jupiter</artifactId>
          <scope>test</scope>
          <note>Already included - for unit tests</note>
        </dependency>
      </maven>

      <note>
        NO NEW DEPENDENCIES REQUIRED for Story 3.1.
        All required dependencies already included from Epic 1 (Foundation).
      </note>
    </dependencies>
  </artifacts>

  <interfaces>
    <interface>
      <name>SignatureProviderPort</name>
      <kind>Domain Port Interface (Outbound)</kind>
      <signature><![CDATA[
package com.bank.signature.domain.port.outbound;

/**
 * Outbound port for sending signature challenges via external providers.
 * Implementations in infrastructure layer handle specific provider integrations.
 * 
 * @since Story 3.1
 */
public interface SignatureProviderPort {
    
    /**
     * Send a signature challenge to the specified recipient.
     * 
     * @param challenge The challenge to send (contains recipient, message, channel type)
     * @return ProviderResult with success status and provider metadata
     */
    ProviderResult sendChallenge(SignatureChallenge challenge);
    
    /**
     * Check health status of provider.
     * 
     * @param providerType The provider to check
     * @return HealthStatus with details
     */
    HealthStatus checkHealth(ProviderType providerType);
}
      ]]></signature>
      <path>src/main/java/com/bank/signature/domain/port/outbound/SignatureProviderPort.java</path>
    </interface>

    <interface>
      <name>ProviderResult</name>
      <kind>Value Object (Java 21 Record)</kind>
      <signature><![CDATA[
package com.bank.signature.domain.model.valueobject;

import java.time.Instant;

/**
 * Immutable result from provider challenge delivery attempt.
 * 
 * @param success True if challenge sent successfully
 * @param providerChallengeId Provider's tracking ID (e.g., Twilio message_sid)
 * @param providerProof Full JSON response for non-repudiation (nullable if failure)
 * @param errorCode Standardized error code (nullable if success)
 * @param errorMessage Human-readable error (nullable if success)
 * @param timestamp When result was created
 * @since Story 3.1
 */
public record ProviderResult(
    boolean success,
    String providerChallengeId,
    String providerProof,
    String errorCode,
    String errorMessage,
    Instant timestamp
) {
    // Compact constructor with validation
    public ProviderResult {
        Objects.requireNonNull(timestamp, "timestamp cannot be null");
        if (success) {
            Objects.requireNonNull(providerChallengeId, "providerChallengeId required for success");
            Objects.requireNonNull(providerProof, "providerProof required for success");
        } else {
            Objects.requireNonNull(errorCode, "errorCode required for failure");
            Objects.requireNonNull(errorMessage, "errorMessage required for failure");
        }
    }
    
    /**
     * Factory method for successful result.
     */
    public static ProviderResult success(String challengeId, String proof) {
        return new ProviderResult(true, challengeId, proof, null, null, Instant.now());
    }
    
    /**
     * Factory method for failure result.
     */
    public static ProviderResult failure(String errorCode, String errorMessage) {
        return new ProviderResult(false, null, null, errorCode, errorMessage, Instant.now());
    }
}
      ]]></signature>
      <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderResult.java</path>
    </interface>

    <interface>
      <name>ProviderType</name>
      <kind>Enum</kind>
      <signature><![CDATA[
package com.bank.signature.domain.model.valueobject;

/**
 * External provider types for challenge delivery.
 * 
 * @since Story 3.1
 */
public enum ProviderType {
    SMS("SMS Provider"),
    PUSH("Push Notification Provider"),
    VOICE("Voice Call Provider"),
    BIOMETRIC("Biometric Provider");
    
    private final String displayName;
    
    ProviderType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
      ]]></signature>
      <path>src/main/java/com/bank/signature/domain/model/valueobject/ProviderType.java</path>
    </interface>
  </interfaces>

  <constraints>
    <constraint id="HEXA-1" priority="CRITICAL">
      SignatureProviderPort MUST reside in com.bank.signature.domain.port.outbound package.
      This is the hexagonal outbound port pattern.
    </constraint>

    <constraint id="PURITY-1" priority="CRITICAL">
      SignatureProviderPort interface MUST have ZERO dependencies on infrastructure packages:
      - NO com.twilio.*
      - NO com.google.firebase.*
      - NO org.springframework.web.client.*
      - NO org.apache.http.*
      - ONLY java.* and com.bank.signature.domain.*
    </constraint>

    <constraint id="PURITY-2" priority="CRITICAL">
      All value objects (ProviderResult, ProviderType, HealthStatus) MUST be in
      com.bank.signature.domain.model.valueobject package with ZERO infrastructure dependencies.
    </constraint>

    <constraint id="RECORD-1" priority="HIGH">
      ProviderResult and HealthStatus MUST be Java 21 records (NOT classes).
      Use compact constructor for validation.
      Follow Money.java pattern for consistency.
    </constraint>

    <constraint id="RECORD-2" priority="HIGH">
      Records MUST be immutable (no setters, no mutable fields).
      All validation in compact constructor.
    </constraint>

    <constraint id="FACTORY-1" priority="HIGH">
      ProviderResult MUST have factory methods: success() and failure().
      HealthStatus MUST have factory methods: UP() and DOWN().
      Follow established pattern from domain layer.
    </constraint>

    <constraint id="ENUM-1" priority="MEDIUM">
      ProviderType enum MUST have exactly 4 values: SMS, PUSH, VOICE, BIOMETRIC.
      Each value MUST have descriptive displayName field.
    </constraint>

    <constraint id="MAPPING-1" priority="HIGH">
      ChannelType.toProviderType() MUST map:
      - SMS → ProviderType.SMS
      - PUSH → ProviderType.PUSH
      - VOICE → ProviderType.VOICE
      - BIOMETRIC → ProviderType.BIOMETRIC
    </constraint>

    <constraint id="JAVADOC-1" priority="HIGH">
      SignatureProviderPort MUST have comprehensive JavaDoc:
      - Interface-level description
      - Method @param, @return, @throws
      - Usage examples in @example or code snippets
    </constraint>

    <constraint id="ARCHUNIT-1" priority="CRITICAL">
      ArchUnit test MUST validate:
      - domain.port.outbound classes do NOT depend on infrastructure packages
      - domain.port.outbound classes do NOT depend on external libs (Twilio, FCM, HTTP)
      - SignatureProviderPort is interface (not class)
    </constraint>

    <constraint id="TEST-1" priority="HIGH">
      Unit tests MUST be pure JUnit 5 (NO Spring dependencies).
      Target coverage > 90% for all new value objects and enums.
    </constraint>

    <constraint id="TEST-2" priority="HIGH">
      Test file naming convention:
      - ProviderResultTest.java (suffix: Test)
      - ProviderTypeTest.java
      - HealthStatusTest.java
      Location: src/test/java/com/bank/signature/domain/model/valueobject/
    </constraint>

    <constraint id="DOC-1" priority="MEDIUM">
      README.md MUST include Provider Abstraction section with:
      - Brief description of hexagonal pattern
      - Code example of SignatureProviderPort usage
      - Link to tech-spec-epic-3.md
    </constraint>

    <constraint id="DOC-2" priority="MEDIUM">
      CHANGELOG.md MUST include Story 3.1 entry with:
      - Files created (4 new files)
      - Files modified (2 modified files)
      - Key features (provider abstraction, domain purity)
    </constraint>
  </constraints>

  <tests>
    <standards>
      <framework>JUnit 5 (org.junit.jupiter)</framework>
      <pattern>Pure unit tests - NO Spring dependencies</pattern>
      <location>src/test/java/com/bank/signature/domain/model/valueobject/</location>
      <naming>ClassNameTest.java (e.g., ProviderResultTest.java)</naming>
      <coverage-target>&gt; 90% for provider abstraction package</coverage-target>
      <archunit>HexagonalArchitectureTest.java validates domain purity</archunit>
    </standards>

    <ideas>
      <test-idea id="1" ac="AC5, AC10">
        <name>testProviderResult_success_shouldCreateValidResult</name>
        <scenario>
          Given: valid challengeId "SM123" and proof JSON
          When: ProviderResult.success("SM123", "{\"status\":\"sent\"}")
          Then: success=true, providerChallengeId="SM123", providerProof contains "sent",
          errorCode=null, errorMessage=null, timestamp NOT null
        </scenario>
      </test-idea>

      <test-idea id="2" ac="AC5, AC10">
        <name>testProviderResult_failure_shouldCreateValidResult</name>
        <scenario>
          Given: valid errorCode "TIMEOUT" and errorMessage "Provider timeout exceeded"
          When: ProviderResult.failure("TIMEOUT", "Provider timeout exceeded")
          Then: success=false, providerChallengeId=null, providerProof=null,
          errorCode="TIMEOUT", errorMessage contains "timeout", timestamp NOT null
        </scenario>
      </test-idea>

      <test-idea id="3" ac="AC4, AC10">
        <name>testProviderResult_success_shouldRequireNonNullChallengeId</name>
        <scenario>
          Given: null challengeId
          When: ProviderResult.success(null, "proof")
          Then: throws NullPointerException or IllegalArgumentException
        </scenario>
      </test-idea>

      <test-idea id="4" ac="AC4, AC10">
        <name>testProviderResult_failure_shouldRequireNonNullErrorCode</name>
        <scenario>
          Given: null errorCode
          When: ProviderResult.failure(null, "message")
          Then: throws NullPointerException or IllegalArgumentException
        </scenario>
      </test-idea>

      <test-idea id="5" ac="AC4">
        <name>testProviderResult_timestamp_shouldBePopulatedAutomatically</name>
        <scenario>
          Given: factory methods called
          When: ProviderResult.success() or failure()
          Then: timestamp is NOT null, timestamp &lt;= Instant.now()
        </scenario>
      </test-idea>

      <test-idea id="6" ac="AC6, AC11">
        <name>testProviderType_values_shouldContainAllTypes</name>
        <scenario>
          When: ProviderType.values()
          Then: array length = 4, contains SMS, PUSH, VOICE, BIOMETRIC
        </scenario>
      </test-idea>

      <test-idea id="7" ac="AC6, AC11">
        <name>testProviderType_getDisplayName_shouldReturnDescriptiveNames</name>
        <scenario>
          Given: ProviderType.SMS
          When: SMS.getDisplayName()
          Then: returns "SMS Provider"
          (Repeat for PUSH, VOICE, BIOMETRIC)
        </scenario>
      </test-idea>

      <test-idea id="8" ac="AC7">
        <name>testHealthStatus_UP_shouldCreateHealthyStatus</name>
        <scenario>
          When: HealthStatus.UP("Service operational")
          Then: status=UP, details="Service operational", timestamp NOT null
        </scenario>
      </test-idea>

      <test-idea id="9" ac="AC7">
        <name>testHealthStatus_DOWN_shouldCreateUnhealthyStatus</name>
        <scenario>
          When: HealthStatus.DOWN("Connection failed")
          Then: status=DOWN, details contains "failed", timestamp NOT null
        </scenario>
      </test-idea>

      <test-idea id="10" ac="MAPPING-1">
        <name>testChannelType_toProviderType_shouldMapSmsToSmsProvider</name>
        <scenario>
          When: ChannelType.SMS.toProviderType()
          Then: returns ProviderType.SMS
        </scenario>
      </test-idea>

      <test-idea id="11" ac="MAPPING-1">
        <name>testChannelType_toProviderType_shouldMapAllChannelTypes</name>
        <scenario>
          Given: all ChannelType values
          When: iterate and call toProviderType()
          Then: each maps to correct ProviderType (SMS→SMS, PUSH→PUSH, VOICE→VOICE,
          BIOMETRIC→BIOMETRIC)
        </scenario>
      </test-idea>

      <test-idea id="12" ac="AC9">
        <name>testArchUnit_domainPortsShouldNotDependOnInfrastructure</name>
        <scenario>
          Given: ArchUnit rule
          When: validate domain.port.outbound package
          Then: NO classes depend on infrastructure packages or external libs (Twilio, FCM, HTTP)
        </scenario>
      </test-idea>
    </ideas>
  </tests>

  <implementation-notes>
    <note priority="CRITICAL">
      <title>Domain Purity is Non-Negotiable</title>
      <content>
        SignatureProviderPort MUST have ZERO infrastructure dependencies.
        This is validated by ArchUnit test. Any import from infrastructure package
        or external library (Twilio, FCM, HTTP clients) will FAIL the test.

        Rationale: Domain purity enables testing without infrastructure,
        provider swapping without domain changes, and clear Separation of Concerns.
      </content>
    </note>

    <note priority="CRITICAL">
      <title>Java 21 Records Pattern</title>
      <content>
        Use Java 21 records for ProviderResult and HealthStatus (NOT classes).
        Follow Money.java pattern:
        - Compact constructor for validation
        - Factory methods for convenient creation
        - Immutable by default (records cannot have setters)

        Example from Money.java shows compact constructor validation and
        business methods pattern.
      </content>
    </note>

    <note priority="HIGH">
      <title>ArchUnit Test Pattern</title>
      <content>
        HexagonalArchitectureTest.java already exists with existing tests.
        Add new test method domainPortsShouldNotDependOnInfrastructure().

        Use ArchUnit API:
        noClasses().that().resideInAPackage("..domain.port.outbound..")
        .should().dependOnClassesThat().resideInAPackage("..infrastructure..")
      </content>
    </note>

    <note priority="HIGH">
      <title>ChannelType Extension</title>
      <content>
        ChannelType enum already exists in domain/model/valueobject/.
        Add method toProviderType() to enable mapping to ProviderType.

        This maintains loose coupling between channel types (used by domain)
        and provider types (used by infrastructure).
      </content>
    </note>

    <note priority="MEDIUM">
      <title>Test Coverage Priority</title>
      <content>
        Priority 1: ProviderResult factory methods (AC5, AC10) - 6+ tests
        Priority 2: ProviderType enum values (AC6, AC11) - 3+ tests
        Priority 3: HealthStatus factory methods (AC7) - 3+ tests
        Priority 4: ChannelType mapping (MAPPING-1) - 2+ tests
        Priority 5: ArchUnit domain purity (AC9) - 1 test

        Target: 15+ test methods total, > 90% coverage
      </content>
    </note>

    <note priority="MEDIUM">
      <title>Documentation Best Practices</title>
      <content>
        JavaDoc on SignatureProviderPort MUST include:
        1. Interface-level description (purpose, hexagonal pattern)
        2. Method-level @param, @return, @throws
        3. Usage example showing typical provider interaction

        Example:
        /**
        * Example usage:
        * {@code
        * SignatureProviderPort provider = ...;
        * ProviderResult result = provider.sendChallenge(challenge);
        * if (result.success()) {
        * log.info("Challenge sent: {}", result.providerChallengeId());
        * }
        * }
        */
      </content>
    </note>

    <note priority="LOW">
      <title>Future Extensibility</title>
      <content>
        ProviderType enum will NOT change in Epic 3 (4 values only).
        Future epics may add: EMAIL, WHATSAPP, TELEGRAM providers.

        Design is extensible - new provider types can be added without
        breaking existing code (enum pattern + switch expressions).
      </content>
    </note>
  </implementation-notes>

  <definition-of-done>
    <item>✓ 4 new files created (SignatureProviderPort, ProviderResult, ProviderType, HealthStatus)</item>
    <item>✓ 2 files modified (ChannelType with toProviderType(), HexagonalArchitectureTest)</item>
    <item>✓ All 12 Acceptance Criteria validated</item>
    <item>✓ 15+ unit tests implemented and PASSING</item>
    <item>✓ Test coverage &gt; 90% for provider abstraction package</item>
    <item>✓ ArchUnit domain purity test PASSING</item>
    <item>✓ mvn clean compile SUCCESS (zero compilation errors)</item>
    <item>✓ mvn test SUCCESS (all tests passing)</item>
    <item>✓ mvn jacoco:report generated with coverage &gt; 90%</item>
    <item>✓ Zero linter errors in new files</item>
    <item>✓ JavaDoc complete on SignatureProviderPort with examples</item>
    <item>✓ README.md updated with Provider Abstraction section</item>
    <item>✓ CHANGELOG.md updated with Story 3.1 entry</item>
    <item>✓ Code review ready (clean, documented, tested)</item>
  </definition-of-done>
</story-context>