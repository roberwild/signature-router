<?xml version="1.0" encoding="UTF-8"?>
<story-context id="signature-router-10-5-context" version="1.0">
  <metadata>
    <epicId>10</epicId>
    <storyId>10.5</storyId>
    <storyKey>10-5-idempotency-functional</storyKey>
    <title>Idempotencia Funcional - IdempotencyService</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-29</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/10-5-idempotency-functional.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Client Application</asA>
    <iWant>Enviar Idempotency-Key header para prevenir procesamiento duplicado</iWant>
    <soThat>Doble-click no cause doble SMS/doble costo</soThat>
    
    <context>
      Esta story implementa idempotencia funcional para prevenir procesamiento duplicado de requests. 
      Actualmente, si un cliente envía el mismo request dos veces (por ejemplo, doble-click), 
      el sistema procesa ambas requests, resultando en doble SMS y doble costo.
      
      Source: Evaluación de Calidad identificó que idempotencia no es funcional actualmente.
      
      Business Value: Previene doble procesamiento (crítico para sistemas bancarios), reduce costos, 
      mejora experiencia de usuario, cumple con estándares bancarios de idempotencia.
    </context>

    <tasks>
      <task id="1" ac="AC1">
        <title>Create Database Schema</title>
        <subtasks>
          <subtask id="1.1">Crear LiquidBase changeset para tabla idempotency_record</subtask>
          <subtask id="1.2">Agregar índices (idempotency_key, expires_at)</subtask>
          <subtask id="1.3">Ejecutar migration y verificar tabla creada</subtask>
          <subtask id="1.4">Crear rollback script</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/main/resources/db/changelog/changesets/XXXX-idempotency-record-table.yaml</file>
        </filesToCreate>
      </task>
      
      <task id="2" ac="AC2">
        <title>Create Domain Model</title>
        <subtasks>
          <subtask id="2.1">Crear IdempotencyRecord entity en domain/model/</subtask>
          <subtask id="2.2">Crear IdempotencyRepository port en domain/port/outbound/</subtask>
          <subtask id="2.3">Crear IdempotencyKeyConflictException en domain/exception/</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/main/java/com/bank/signature/domain/model/IdempotencyRecord.java</file>
          <file>src/main/java/com/bank/signature/domain/port/outbound/IdempotencyRepository.java</file>
          <file>src/main/java/com/bank/signature/domain/exception/IdempotencyKeyConflictException.java</file>
        </filesToCreate>
      </task>
      
      <task id="3" ac="AC2,AC3">
        <title>Implement IdempotencyService</title>
        <subtasks>
          <subtask id="3.1">Crear IdempotencyService en application/service/</subtask>
          <subtask id="3.2">Implementar checkAndStore() method</subtask>
          <subtask id="3.3">Implementar storeResponse() method</subtask>
          <subtask id="3.4">Implementar cleanupExpiredRecords() method</subtask>
          <subtask id="3.5">Agregar JavaDoc completo</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/main/java/com/bank/signature/application/service/IdempotencyService.java</file>
        </filesToCreate>
      </task>
      
      <task id="4" ac="AC3">
        <title>Create HashService</title>
        <subtasks>
          <subtask id="4.1">Crear HashService utility para SHA-256</subtask>
          <subtask id="4.2">Implementar método sha256(Object) que serializa a JSON y hashea</subtask>
          <subtask id="4.3">Agregar tests unitarios</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/main/java/com/bank/signature/application/service/HashService.java</file>
        </filesToCreate>
      </task>
      
      <task id="5" ac="AC4,AC5,AC6,AC7,AC8">
        <title>Integrate in Controller</title>
        <subtasks>
          <subtask id="5.1">Modificar POST /api/v1/signatures controller</subtask>
          <subtask id="5.2">Extraer Idempotency-Key header</subtask>
          <subtask id="5.3">Calcular request hash</subtask>
          <subtask id="5.4">Integrar IdempotencyService</subtask>
          <subtask id="5.5">Manejar HTTP 409 Conflict</subtask>
        </subtasks>
        <filesToModify>
          <file>src/main/java/com/bank/signature/infrastructure/adapter/inbound/rest/SignatureController.java</file>
        </filesToModify>
      </task>
      
      <task id="6" ac="AC2">
        <title>Create Repository Adapter</title>
        <subtasks>
          <subtask id="6.1">Crear IdempotencyRepositoryAdapter implementando port</subtask>
          <subtask id="6.2">Crear JPA entity IdempotencyRecordEntity</subtask>
          <subtask id="6.3">Crear Spring Data JPA repository</subtask>
          <subtask id="6.4">Implementar métodos: findByKey(), save(), deleteExpired()</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/main/java/com/bank/signature/infrastructure/adapter/outbound/persistence/IdempotencyRepositoryAdapter.java</file>
          <file>src/main/java/com/bank/signature/infrastructure/adapter/outbound/persistence/entity/IdempotencyRecordEntity.java</file>
          <file>src/main/java/com/bank/signature/infrastructure/adapter/outbound/persistence/repository/IdempotencyRecordJpaRepository.java</file>
        </filesToCreate>
      </task>
      
      <task id="7" ac="AC9">
        <title>Create Cleanup Job</title>
        <subtasks>
          <subtask id="7.1">Crear IdempotencyCleanupJob con @Scheduled</subtask>
          <subtask id="7.2">Configurar cron expression (cada hora)</subtask>
          <subtask id="7.3">Agregar @EnableScheduling en main class si no existe</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/main/java/com/bank/signature/infrastructure/job/IdempotencyCleanupJob.java</file>
        </filesToCreate>
      </task>
      
      <task id="8" ac="AC10">
        <title>Write Tests</title>
        <subtasks>
          <subtask id="8.1">Crear IdempotencyServiceTest (unit tests con mocks)</subtask>
          <subtask id="8.2">Crear IdempotencyControllerTest (integration tests)</subtask>
          <subtask id="8.3">Test: duplicate request → cached response</subtask>
          <subtask id="8.4">Test: key conflict → HTTP 409</subtask>
          <subtask id="8.5">Test: expired key → new request</subtask>
          <subtask id="8.6">Test: auto-generate key</subtask>
          <subtask id="8.7">Test: cleanup job</subtask>
        </subtasks>
        <filesToCreate>
          <file>src/test/java/com/bank/signature/application/service/IdempotencyServiceTest.java</file>
          <file>src/test/java/com/bank/signature/infrastructure/adapter/inbound/rest/IdempotencyControllerTest.java</file>
        </filesToCreate>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">
      <title>Idempotency Record Table Created</title>
      <given>LiquidBase migrations</given>
      <when>Ejecuto migrations</when>
      <then>
        Se crea tabla idempotency_record con:
        - id UUID PRIMARY KEY (default uuid_generate_v7())
        - idempotency_key VARCHAR(255) UNIQUE NOT NULL
        - request_hash VARCHAR(64) NOT NULL (SHA-256)
        - response_body JSONB NOT NULL
        - status_code INTEGER NOT NULL
        - created_at TIMESTAMP NOT NULL DEFAULT NOW()
        - expires_at TIMESTAMP NOT NULL
        Índice en idempotency_key y expires_at
      </then>
      <verification>Tabla creada y migración ejecuta sin errores</verification>
    </criterion>

    <criterion id="AC2">
      <title>IdempotencyService Implemented</title>
      <given>Application layer</given>
      <when>Reviso com.bank.signature.application.service</when>
      <then>
        Existe IdempotencyService con métodos:
        - Optional&lt;IdempotencyRecord&gt; checkAndStore(String key, String hash)
        - Optional&lt;IdempotencyRecord&gt; getCachedResponse(String key)
        - void cleanupExpiredRecords()
      </then>
      <verification>Clase existe y compila</verification>
    </criterion>

    <criterion id="AC3">
      <title>Request Hash Calculation</title>
      <given>Request body</given>
      <when>Sistema calcula hash</when>
      <then>
        Usa SHA-256 del request body serializado como JSON
        Hash es consistente (mismo body → mismo hash)
      </then>
      <verification>HashService genera mismo hash para mismo input</verification>
    </criterion>

    <criterion id="AC4">
      <title>Controller Integration</title>
      <given>POST /api/v1/signatures endpoint</given>
      <when>Request incluye header Idempotency-Key</when>
      <then>
        Controller:
        - Extrae header Idempotency-Key (opcional)
        - Calcula request_hash del body
        - Llama a IdempotencyService.checkAndStore()
        - Si existe y hash coincide: retorna cached response
        - Si existe y hash difiere: retorna HTTP 409 Conflict
        - Si no existe: procesa request y guarda response
      </then>
      <verification>Integration test pasa</verification>
    </criterion>

    <criterion id="AC5">
      <title>Duplicate Request Handling</title>
      <given>Request con Idempotency-Key: uuid-123 procesado exitosamente</given>
      <when>Cliente reenvía MISMO request con mismo key dentro de 24h</when>
      <then>
        Sistema:
        - Detecta duplicate en idempotency_record
        - Valida request_hash coincide
        - Retorna cached response_body (HTTP 200/201 según original)
        - NO ejecuta use case nuevamente
        - NO envía SMS duplicado
      </then>
      <verification>Test: duplicate request → cached response</verification>
    </criterion>

    <criterion id="AC6">
      <title>Key Conflict Handling</title>
      <given>Request con Idempotency-Key: uuid-123 ya procesado</given>
      <when>Cliente envía DIFERENTE request con mismo key</when>
      <then>
        Sistema:
        - Detecta duplicate en idempotency_record
        - Valida request_hash NO coincide
        - Retorna HTTP 409 Conflict con mensaje: "Idempotency key reused with different request"
        - NO procesa request
      </then>
      <verification>Test: key conflict → HTTP 409</verification>
    </criterion>

    <criterion id="AC7">
      <title>Expired Key Handling</title>
      <given>Request con Idempotency-Key: uuid-123 procesado hace &gt;24h</given>
      <when>Cliente reenvía request con mismo key</when>
      <then>
        Sistema:
        - Detecta que key expiró (expires_at &lt; NOW())
        - Procesa como nuevo request
        - Guarda nuevo registro con mismo key
        - Limpia registro antiguo (opcional, puede hacerlo cleanup job)
      </then>
      <verification>Test: expired key → new request</verification>
    </criterion>

    <criterion id="AC8">
      <title>Auto-Generate Key If Missing</title>
      <given>Request SIN header Idempotency-Key</given>
      <when>Sistema procesa request</when>
      <then>
        Sistema:
        - Auto-genera UUID como idempotency key
        - Procesa request normalmente
        - Guarda registro con key generado
        - Retorna response normalmente (cliente no ve diferencia)
      </then>
      <verification>Test: auto-generate key</verification>
    </criterion>

    <criterion id="AC9">
      <title>Cleanup Job Implemented</title>
      <given>Scheduled job</given>
      <when>Job ejecuta (cada hora)</when>
      <then>
        Elimina registros donde expires_at &lt; NOW()
        Job es idempotente (puede ejecutar múltiples veces sin error)
      </then>
      <verification>Test: cleanup job elimina registros expirados</verification>
    </criterion>

    <criterion id="AC10">
      <title>Tests Implemented</title>
      <given>Test suite</given>
      <when>Ejecuto tests de idempotencia</when>
      <then>
        Tests cubren:
        - Duplicate request → cached response
        - Key conflict → HTTP 409
        - Expired key → new request
        - Auto-generate key
        - Cleanup job
      </then>
      <verification>Todos los tests pasan</verification>
    </criterion>
  </acceptanceCriteria>

  <technicalNotes>
    <note>
      IdempotencyService debe ser thread-safe ya que múltiples requests pueden llegar simultáneamente 
      con el mismo idempotency key. Usar @Transactional con isolation level apropiado.
    </note>
    <note>
      Performance: Lookup en BD puede agregar latencia. Considerar cache en memoria (Caffeine) 
      con TTL corto, BD como source of truth.
    </note>
    <note>
      JSONB serialization puede fallar con objetos complejos. Usar Jackson ObjectMapper, 
      manejar excepciones gracefully.
    </note>
  </technicalNotes>

  <dependencies>
    <internal>
      <prerequisite>Epic 1 completado (PostgreSQL, LiquidBase)</prerequisite>
      <prerequisite>Epic 2 completado (POST /api/v1/signatures endpoint)</prerequisite>
    </internal>
    <external>
      <library>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
        <scope>compile</scope>
        <reason>JSON serialization para response_body</reason>
      </library>
    </external>
  </dependencies>

  <testStrategy>
    <unitTests>
      IdempotencyServiceTest: Mock repository, test lógica de negocio
      HashServiceTest: Test SHA-256 calculation
    </unitTests>
    <integrationTests>
      IdempotencyControllerTest: Test completo con Testcontainers PostgreSQL
      Test scenarios: duplicate, conflict, expired, auto-generate
    </integrationTests>
    <manualTesting>
      Enviar request con Idempotency-Key header
      Reenviar mismo request → verificar cached response
      Enviar diferente request con mismo key → verificar HTTP 409
    </manualTesting>
  </testStrategy>

  <risks>
    <risk>
      <description>Performance impact de lookup en BD</description>
      <mitigation>Índice en idempotency_key, considerar cache en memoria (Caffeine) si necesario</mitigation>
    </risk>
    <risk>
      <description>JSONB serialization puede fallar con objetos complejos</description>
      <mitigation>Usar Jackson ObjectMapper, manejar excepciones gracefully</mitigation>
    </risk>
    <risk>
      <description>Cleanup job puede ser lento con muchos registros</description>
      <mitigation>Batch delete, ejecutar en horarios de bajo tráfico</mitigation>
    </risk>
  </risks>

  <references>
    <reference>Epic 10 Tech Spec: docs/sprint-artifacts/tech-spec-epic-10.md</reference>
    <reference>Quality Evaluation: Evaluación_de_Calidad_del_Proyecto_Signature_Router.md</reference>
    <reference>Idempotency Best Practices: https://stripe.com/docs/api/idempotent_requests</reference>
  </references>
</story-context>
