<?xml version="1.0" encoding="UTF-8"?>
<story-context id="bmad/bmm/workflows/4-implementation/story-context/1-6-jpa-entities-repository-adapters" v="1.0">
  <metadata>
    <epicId>epic-1</epicId>
    <storyId>1.6</storyId>
    <title>JPA Entities & Repository Adapters</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-27</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-6-jpa-entities-repository-adapters.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Developer</asA>
    <iWant>JPA entities y repository adapters para persistencia</iWant>
    <soThat>Puedo persistir/recuperar aggregates desde PostgreSQL siguiendo Hexagonal Architecture</soThat>
    <tasks>
      - Task 1: Create Domain Repository Port Interface (SignatureRequestRepository in domain/port/outbound/)
      - Task 2: Add Maven Dependencies (hypersistence-utils-hibernate-63 for JSONB support)
      - Task 3: Create JPA Entity Classes (SignatureRequestEntity, SignatureChallengeEntity with @Entity, @Table, @Type annotations)
      - Task 4: Create Spring Data JPA Repositories (SignatureRequestJpaRepository extends JpaRepository)
      - Task 5: Create Entity Mappers (SignatureRequestEntityMapper, SignatureChallengeEntityMapper for bidirectional mapping)
      - Task 6: Create Repository Adapter (SignatureRequestRepositoryAdapter implements domain port)
      - Task 7: Configure Hibernate JSONB Support (Hypersistence Utils or custom JsonBinaryType)
      - Task 8: Create Integration Tests (SignatureRequestRepositoryIntegrationTest with Testcontainers PostgreSQL)
      - Task 9: Update ArchUnit Tests (3 new tests: domain ports purity, infrastructure isolation, adapter contract)
      - Task 10: Update Documentation (README persistence section, CHANGELOG Story 1.6 entry)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1" title="JPA Entity Classes Created">
      <given>Domain models (SignatureRequest, SignatureChallenge) existen (Story 1.5)</given>
      <when>Creo JPA entities en infrastructure/adapter/outbound/persistence/entity/</when>
      <then>
        - Clase SignatureRequestEntity con @Entity, @Table(name = "signature_request")
        - @Id private UUID id (UUIDv7)
        - Fields mapeados a columnas (customerId, status, createdAt, expiresAt, signedAt)
        - @Type(JsonBinaryType.class) para transaction_context JSONB column
        - @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) para challenges
        - @Type(JsonBinaryType.class) para routing_timeline JSONB column (List&lt;RoutingEvent&gt;)
        - Clase SignatureChallengeEntity con @Entity, @Table(name = "signature_challenge")
        - @ManyToOne back-reference a SignatureRequestEntity
        - @Type(JsonBinaryType.class) para provider_proof JSONB column
      </then>
    </criterion>

    <criterion id="AC2" title="Spring Data JPA Repositories Created">
      <given>JPA entities creadas</given>
      <when>Creo JPA repositories en infrastructure/adapter/outbound/persistence/repository/</when>
      <then>
        - SignatureRequestJpaRepository extends JpaRepository&lt;SignatureRequestEntity, UUID&gt;
        - Métodos custom queries: findByIdWithChallenges (eager loading), findByCustomerId, findByStatusAndExpiresAtBefore
      </then>
    </criterion>

    <criterion id="AC3" title="Entity Mappers (Bidirectional)">
      <given>Domain models y JPA entities existen</given>
      <when>Creo mappers en infrastructure/adapter/outbound/persistence/mapper/</when>
      <then>
        - SignatureRequestEntityMapper con métodos: toEntity(domain), toDomain(entity), updateEntity(domain, entity)
        - SignatureChallengeEntityMapper similar
        - Mapeo correcto de Value Objects (Money, TransactionContext) → JSONB serialization (Jackson)
        - Mapeo correcto de enums → String columns, Collections (challenges, routingTimeline)
      </then>
    </criterion>

    <criterion id="AC4" title="Domain Repository Port Interface">
      <given>Domain layer debe permanecer puro</given>
      <when>Creo port interface en domain/port/outbound/</when>
      <then>
        - Interface SignatureRequestRepository con métodos: save, findById, findByCustomerId, findExpired, delete
        - NO dependencies on JPA, Spring, Jackson (domain purity)
      </then>
    </criterion>

    <criterion id="AC5" title="Repository Adapter Implementation">
      <given>Domain port interface y JPA repository existen</given>
      <when>Creo adapter en infrastructure/adapter/outbound/persistence/adapter/</when>
      <then>
        - SignatureRequestRepositoryAdapter implements SignatureRequestRepository
        - Usa SignatureRequestJpaRepository internamente (dependency injection)
        - Usa SignatureRequestEntityMapper para conversiones
        - Retorna domain models (NO JPA entities)
      </then>
    </criterion>

    <criterion id="AC6" title="Hibernate JSONB Support Configuration">
      <given>PostgreSQL JSONB columns necesitan custom type</given>
      <when>Configuro Hibernate para JSONB</when>
      <then>
        - Dependency io.hypersistence:hypersistence-utils-hibernate-63 agregada a pom.xml
        - @Type(JsonBinaryType.class) funciona en JPA entities
        - TransactionContext, ProviderResult, List&lt;RoutingEvent&gt; se serializan/deserializan correctamente
      </then>
    </criterion>

    <criterion id="AC7" title="Integration Tests (Testcontainers)">
      <given>JPA entities y repository adapter implementados</given>
      <when>Creo integration test en test/java/infrastructure/adapter/outbound/persistence/</when>
      <then>
        - SignatureRequestRepositoryIntegrationTest con @SpringBootTest, @Testcontainers
        - @Container PostgreSQLContainer para base de datos real
        - 6 test methods: testSaveAndFindById, testCascadePersistChallenges, testJsonbSerializationTransactionContext, testUpdateExistingRequest, testFindByCustomerId, testFindExpired
        - Todos los tests passing (0 failures), coverage > 80%
      </then>
    </criterion>

    <criterion id="AC8" title="Transactional Behavior">
      <given>Repository adapter usa Spring Data JPA</given>
      <when>Invoco métodos save/delete</when>
      <then>
        - Métodos repository adapter anotados con @Transactional (read-only = false para writes, true para reads)
        - Rollback automático en caso de exception
      </then>
    </criterion>

    <criterion id="AC9" title="Package Structure (Hexagonal)">
      <given>Hexagonal Architecture enforcement</given>
      <when>Reviso estructura de packages</when>
      <then>
        - domain/port/outbound/SignatureRequestRepository.java (port interface)
        - infrastructure/adapter/outbound/persistence/entity/ (SignatureRequestEntity, SignatureChallengeEntity)
        - infrastructure/adapter/outbound/persistence/repository/ (SignatureRequestJpaRepository)
        - infrastructure/adapter/outbound/persistence/mapper/ (mappers)
        - infrastructure/adapter/outbound/persistence/adapter/ (SignatureRequestRepositoryAdapter)
      </then>
    </criterion>

    <criterion id="AC10" title="ArchUnit Tests Updated">
      <given>Domain purity debe mantenerse</given>
      <when>Actualizo HexagonalArchitectureTest.java</when>
      <then>
        - Test domainPortsShouldNotDependOnInfrastructure() agregado
        - Test infrastructureShouldNotLeakToApplication() agregado
        - Test repositoryAdapterShouldImplementDomainPort() agregado
      </then>
    </criterion>

    <criterion id="AC11" title="Documentation & Examples">
      <given>Story 1.6 implementado</given>
      <when>Actualizo documentación</when>
      <then>
        - README.md actualizado con sección "Persistence Layer (JPA)"
        - CHANGELOG.md actualizado con Story 1.6 entry
        - JavaDoc en SignatureRequestRepository port interface
        - JavaDoc en SignatureRequestRepositoryAdapter
      </then>
    </criterion>

    <criterion id="AC12" title="Maven Dependencies Added">
      <given>Story 1.6 requiere nuevas dependencies</given>
      <when>Actualizo pom.xml</when>
      <then>
        - spring-boot-starter-data-jpa (ya incluido desde Story 1.1)
        - io.hypersistence:hypersistence-utils-hibernate-63 version 3.7.0 agregado
      </then>
    </criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <artifact id="database-schema" path="docs/architecture/03-database-schema.md">
        <section name="signature_request Table" lines="26-35">
          <ddl><![CDATA[
CREATE TABLE signature_request (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    customer_id VARCHAR(255) NOT NULL,
    transaction_context JSONB NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('PENDING', 'CHALLENGED', 'SIGNED', 'ABORTED', 'EXPIRED')),
    routing_timeline JSONB NOT NULL DEFAULT '[]',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,
    signed_at TIMESTAMPTZ
);

CREATE INDEX idx_signature_request_customer_id ON signature_request(customer_id);
CREATE INDEX idx_signature_request_status ON signature_request(status);
CREATE INDEX idx_signature_request_created_at ON signature_request(created_at DESC);
CREATE INDEX idx_signature_request_transaction_context ON signature_request USING GIN(transaction_context);
CREATE INDEX idx_signature_request_routing_timeline ON signature_request USING GIN(routing_timeline);
          ]]></ddl>
        </section>
        <section name="signature_challenge Table" lines="39-55">
          <ddl><![CDATA[
CREATE TABLE signature_challenge (
    id UUID PRIMARY KEY DEFAULT uuidv7(),
    signature_request_id UUID NOT NULL REFERENCES signature_request(id) ON DELETE CASCADE,
    channel_type VARCHAR(20) NOT NULL CHECK (channel_type IN ('SMS', 'PUSH', 'VOICE', 'BIOMETRIC')),
    provider VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('SENT', 'PENDING', 'COMPLETED', 'FAILED', 'EXPIRED')),
    sent_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    provider_proof JSONB,
    error_code VARCHAR(100),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_signature_challenge_request_id ON signature_challenge(signature_request_id);
CREATE INDEX idx_signature_challenge_status ON signature_challenge(status);
CREATE INDEX idx_signature_challenge_provider_proof ON signature_challenge USING GIN(provider_proof);
          ]]></ddl>
        </section>
      </artifact>

      <artifact id="tech-spec-epic-1" path="docs/sprint-artifacts/tech-spec-epic-1.md">
        <section name="Persistence Layer" lines="168">
          <jpa_strategy>Spring Data JPA with Hibernate 6.3</jpa_strategy>
          <jsonb_handling>Hypersistence Utils @Type(JsonBinaryType.class) for PostgreSQL JSONB</jsonb_handling>
          <mapper_strategy>Manual mapping (simple, explicit, no compile-time code generation)</mapper_strategy>
          <hexagonal_pattern>Domain port interface in domain/port/outbound/, adapter in infrastructure/</hexagonal_pattern>
        </section>
      </artifact>

      <artifact id="hexagonal-architecture" path="docs/architecture/02-hexagonal-structure.md">
        <section name="Outbound Ports & Adapters" lines="200-280">
          <purpose>External systems (database, Kafka, Vault) accessed via adapters implementing domain ports</purpose>
          <pattern>Domain defines port interface (SignatureRequestRepository), infrastructure implements adapter</pattern>
          <benefit>Domain remains pure, infrastructure swappable (e.g., MongoDB adapter)</benefit>
        </section>
      </artifact>

      <artifact id="epics" path="docs/epics.md">
        <section name="Story 1.6 Definition" lines="313-345">
          <description>JPA entities y repository adapters para persistencia</description>
          <prerequisites>Story 1.2 (database schema), Story 1.5 (domain models)</prerequisites>
        </section>
      </artifact>
    </docs>

    <code>
      <artifact id="signature-request-domain" type="java" path="src/main/java/com/bank/signature/domain/model/aggregate/SignatureRequest.java">
        <purpose>Domain aggregate root (reference for JPA entity mapping)</purpose>
        <critical_fields>
          - UUID id (UUIDv7)
          - String customerId
          - TransactionContext transactionContext (Value Object → JSONB)
          - SignatureStatus status (Enum → String)
          - List&lt;SignatureChallenge&gt; challenges (OneToMany relationship)
          - List&lt;RoutingEvent&gt; routingTimeline (Value Object list → JSONB)
          - Instant createdAt, expiresAt, signedAt
        </critical_fields>
      </artifact>

      <artifact id="signature-challenge-domain" type="java" path="src/main/java/com/bank/signature/domain/model/entity/SignatureChallenge.java">
        <purpose>Domain entity (reference for JPA entity mapping)</purpose>
        <critical_fields>
          - UUID id (UUIDv7)
          - ChannelType channelType (Enum → String)
          - ProviderType provider (Enum → String)
          - ChallengeStatus status (Enum → String)
          - Instant sentAt, completedAt
          - ProviderResult providerProof (Value Object → JSONB)
          - String errorCode
        </critical_fields>
      </artifact>

      <artifact id="domain-port-interface-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.domain.port.outbound;

import com.bank.signature.domain.model.aggregate.SignatureRequest;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Domain port interface for SignatureRequest persistence operations.
 * 
 * <p><b>Hexagonal Architecture:</b> This interface is defined in the domain layer
 * and implemented by infrastructure adapters (JPA, MongoDB, etc.).</p>
 * 
 * <p><b>Domain Purity:</b> NO dependencies on JPA, Spring, Jackson, or any framework.</p>
 * 
 * @since Story 1.6
 */
public interface SignatureRequestRepository {
    
    /**
     * Save or update a signature request.
     * 
     * @param request Domain aggregate to persist
     * @return Persisted domain aggregate with generated ID (if new)
     */
    SignatureRequest save(SignatureRequest request);
    
    /**
     * Find signature request by ID.
     * 
     * @param id Signature request ID (UUIDv7)
     * @return Optional containing domain aggregate if found
     */
    Optional<SignatureRequest> findById(UUID id);
    
    /**
     * Find all signature requests for a given customer.
     * 
     * @param customerId Customer identifier (pseudonymized)
     * @return List of domain aggregates (empty if none found)
     */
    List<SignatureRequest> findByCustomerId(String customerId);
    
    /**
     * Find expired signature requests (expiresAt before cutoff time).
     * 
     * @param cutoffTime Cutoff timestamp (e.g., Instant.now())
     * @return List of expired domain aggregates
     */
    List<SignatureRequest> findExpired(Instant cutoffTime);
    
    /**
     * Delete signature request by ID.
     * 
     * @param id Signature request ID
     */
    void delete(UUID id);
}
        ]]></content>
      </artifact>

      <artifact id="jpa-entity-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.outbound.persistence.entity;

import io.hypersistence.utils.hibernate.type.json.JsonBinaryType;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.Type;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * JPA entity for signature_request table.
 * 
 * <p><b>Mapping Strategy:</b> JPA Entity ↔ Domain Aggregate (SignatureRequest) via mapper.</p>
 * <p><b>JSONB Columns:</b> transactionContext, routingTimeline serialized with Jackson.</p>
 * 
 * @since Story 1.6
 */
@Entity
@Table(name = "signature_request")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SignatureRequestEntity {
    
    @Id
    private UUID id;
    
    @Column(name = "customer_id", nullable = false)
    private String customerId;
    
    @Type(JsonBinaryType.class)
    @Column(name = "transaction_context", columnDefinition = "jsonb", nullable = false)
    private String transactionContextJson; // Serialized TransactionContext
    
    @Column(name = "status", length = 20, nullable = false)
    private String status; // SignatureStatus enum → String
    
    @OneToMany(mappedBy = "signatureRequest", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @Builder.Default
    private List<SignatureChallengeEntity> challenges = new ArrayList<>();
    
    @Type(JsonBinaryType.class)
    @Column(name = "routing_timeline", columnDefinition = "jsonb", nullable = false)
    private String routingTimelineJson; // Serialized List<RoutingEvent>
    
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
    
    @Column(name = "expires_at", nullable = false)
    private Instant expiresAt;
    
    @Column(name = "signed_at")
    private Instant signedAt;
}
        ]]></content>
        <critical_notes>
          - @Type(JsonBinaryType.class) requiere hypersistence-utils dependency
          - transactionContextJson es String (Jackson serializado), mapper convierte TransactionContext ↔ JSON
          - @OneToMany con cascade = ALL: challenges persisten automáticamente con parent
          - orphanRemoval = true: challenges eliminados de lista se borran de DB
          - fetch = LAZY: challenges cargados solo cuando necesarios (performance)
        </critical_notes>
      </artifact>

      <artifact id="jpa-repository-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.outbound.persistence.repository;

import com.bank.signature.infrastructure.adapter.outbound.persistence.entity.SignatureRequestEntity;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Spring Data JPA repository for SignatureRequestEntity.
 * 
 * <p><b>Note:</b> This is an INFRASTRUCTURE component, NOT exposed outside persistence package.</p>
 * 
 * @since Story 1.6
 */
@Repository
public interface SignatureRequestJpaRepository extends JpaRepository<SignatureRequestEntity, UUID> {
    
    /**
     * Find signature request by ID with challenges eagerly loaded.
     * 
     * @param id Signature request ID
     * @return Optional containing entity if found
     */
    @EntityGraph(attributePaths = {"challenges"})
    @Query("SELECT sr FROM SignatureRequestEntity sr WHERE sr.id = :id")
    Optional<SignatureRequestEntity> findByIdWithChallenges(UUID id);
    
    /**
     * Find all signature requests by customer ID.
     * 
     * @param customerId Customer identifier
     * @return List of entities (empty if none found)
     */
    List<SignatureRequestEntity> findByCustomerId(String customerId);
    
    /**
     * Find expired signature requests (status PENDING or CHALLENGED + expiresAt before cutoff).
     * 
     * @param status Status filter (e.g., "PENDING")
     * @param expiresAt Cutoff timestamp
     * @return List of expired entities
     */
    List<SignatureRequestEntity> findByStatusAndExpiresAtBefore(String status, Instant expiresAt);
}
        ]]></content>
      </artifact>

      <artifact id="entity-mapper-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.outbound.persistence.mapper;

import com.bank.signature.domain.model.aggregate.SignatureRequest;
import com.bank.signature.domain.model.entity.SignatureChallenge;
import com.bank.signature.domain.model.valueobject.*;
import com.bank.signature.infrastructure.adapter.outbound.persistence.entity.SignatureRequestEntity;
import com.bank.signature.infrastructure.adapter.outbound.persistence.entity.SignatureChallengeEntity;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapper for bidirectional conversion between domain and JPA entities.
 * 
 * <p><b>Mapping Strategy:</b></p>
 * <ul>
 *   <li>Domain SignatureRequest ↔ JPA SignatureRequestEntity</li>
 *   <li>Value Objects (TransactionContext, List&lt;RoutingEvent&gt;) ↔ JSON String (Jackson)</li>
 *   <li>Enums (SignatureStatus, ChallengeStatus) ↔ String</li>
 *   <li>Collections (List&lt;SignatureChallenge&gt;) ↔ List&lt;SignatureChallengeEntity&gt;</li>
 * </ul>
 * 
 * @since Story 1.6
 */
@Component
public class SignatureRequestEntityMapper {
    
    private final ObjectMapper objectMapper;
    private final SignatureChallengeEntityMapper challengeMapper;
    
    public SignatureRequestEntityMapper(ObjectMapper objectMapper, SignatureChallengeEntityMapper challengeMapper) {
        this.objectMapper = objectMapper;
        this.challengeMapper = challengeMapper;
    }
    
    /**
     * Map domain aggregate to JPA entity.
     * 
     * @param domain Domain SignatureRequest
     * @return JPA SignatureRequestEntity
     */
    public SignatureRequestEntity toEntity(SignatureRequest domain) {
        try {
            SignatureRequestEntity entity = SignatureRequestEntity.builder()
                .id(domain.getId())
                .customerId(domain.getCustomerId())
                .transactionContextJson(objectMapper.writeValueAsString(domain.getTransactionContext()))
                .status(domain.getStatus().name())
                .routingTimelineJson(objectMapper.writeValueAsString(domain.getRoutingTimeline()))
                .createdAt(domain.getCreatedAt())
                .expiresAt(domain.getExpiresAt())
                .signedAt(domain.getSignedAt())
                .build();
            
            // Map challenges
            List<SignatureChallengeEntity> challengeEntities = domain.getChallenges().stream()
                .map(challengeMapper::toEntity)
                .peek(ce -> ce.setSignatureRequest(entity))
                .collect(Collectors.toList());
            entity.setChallenges(challengeEntities);
            
            return entity;
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize domain to entity", e);
        }
    }
    
    /**
     * Map JPA entity to domain aggregate.
     * 
     * @param entity JPA SignatureRequestEntity
     * @return Domain SignatureRequest
     */
    public SignatureRequest toDomain(SignatureRequestEntity entity) {
        try {
            TransactionContext transactionContext = objectMapper.readValue(
                entity.getTransactionContextJson(), TransactionContext.class);
            
            List<RoutingEvent> routingTimeline = objectMapper.readValue(
                entity.getRoutingTimelineJson(), new TypeReference<List<RoutingEvent>>() {});
            
            List<SignatureChallenge> challenges = entity.getChallenges().stream()
                .map(challengeMapper::toDomain)
                .collect(Collectors.toList());
            
            return SignatureRequest.builder()
                .id(entity.getId())
                .customerId(entity.getCustomerId())
                .transactionContext(transactionContext)
                .status(SignatureStatus.valueOf(entity.getStatus()))
                .challenges(challenges)
                .routingTimeline(routingTimeline)
                .createdAt(entity.getCreatedAt())
                .expiresAt(entity.getExpiresAt())
                .signedAt(entity.getSignedAt())
                .build();
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize entity to domain", e);
        }
    }
    
    /**
     * Update existing entity from domain aggregate (for updates).
     * 
     * @param domain Domain SignatureRequest
     * @param entity Existing JPA SignatureRequestEntity
     */
    public void updateEntity(SignatureRequest domain, SignatureRequestEntity entity) {
        try {
            entity.setStatus(domain.getStatus().name());
            entity.setRoutingTimelineJson(objectMapper.writeValueAsString(domain.getRoutingTimeline()));
            entity.setSignedAt(domain.getSignedAt());
            
            // Update challenges (clear and re-add)
            entity.getChallenges().clear();
            List<SignatureChallengeEntity> challengeEntities = domain.getChallenges().stream()
                .map(challengeMapper::toEntity)
                .peek(ce -> ce.setSignatureRequest(entity))
                .collect(Collectors.toList());
            entity.getChallenges().addAll(challengeEntities);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to update entity from domain", e);
        }
    }
}
        ]]></content>
      </artifact>

      <artifact id="repository-adapter-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.outbound.persistence.adapter;

import com.bank.signature.domain.model.aggregate.SignatureRequest;
import com.bank.signature.domain.port.outbound.SignatureRequestRepository;
import com.bank.signature.infrastructure.adapter.outbound.persistence.entity.SignatureRequestEntity;
import com.bank.signature.infrastructure.adapter.outbound.persistence.mapper.SignatureRequestEntityMapper;
import com.bank.signature.infrastructure.adapter.outbound.persistence.repository.SignatureRequestJpaRepository;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * JPA adapter implementing domain repository port.
 * 
 * <p><b>Hexagonal Architecture:</b> This adapter implements the domain port interface
 * (SignatureRequestRepository) and delegates to Spring Data JPA repository.</p>
 * 
 * <p><b>Responsibility:</b> Convert between domain models and JPA entities via mapper.</p>
 * 
 * @since Story 1.6
 */
@Component
public class SignatureRequestRepositoryAdapter implements SignatureRequestRepository {
    
    private final SignatureRequestJpaRepository jpaRepository;
    private final SignatureRequestEntityMapper mapper;
    
    public SignatureRequestRepositoryAdapter(
            SignatureRequestJpaRepository jpaRepository,
            SignatureRequestEntityMapper mapper) {
        this.jpaRepository = jpaRepository;
        this.mapper = mapper;
    }
    
    @Override
    @Transactional
    public SignatureRequest save(SignatureRequest request) {
        SignatureRequestEntity entity = mapper.toEntity(request);
        SignatureRequestEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Optional<SignatureRequest> findById(UUID id) {
        return jpaRepository.findByIdWithChallenges(id)
            .map(mapper::toDomain);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<SignatureRequest> findByCustomerId(String customerId) {
        return jpaRepository.findByCustomerId(customerId).stream()
            .map(mapper::toDomain)
            .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<SignatureRequest> findExpired(Instant cutoffTime) {
        return jpaRepository.findByStatusAndExpiresAtBefore("PENDING", cutoffTime).stream()
            .map(mapper::toDomain)
            .collect(Collectors.toList());
    }
    
    @Override
    @Transactional
    public void delete(UUID id) {
        jpaRepository.deleteById(id);
    }
}
        ]]></content>
      </artifact>

      <artifact id="integration-test-template" type="java" path="NOT_YET_CREATED">
        <content><![CDATA[
package com.bank.signature.infrastructure.adapter.outbound.persistence;

import com.bank.signature.domain.model.aggregate.SignatureRequest;
import com.bank.signature.domain.model.entity.SignatureChallenge;
import com.bank.signature.domain.model.valueobject.*;
import com.bank.signature.domain.port.outbound.SignatureRequestRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration test for SignatureRequestRepositoryAdapter with Testcontainers PostgreSQL.
 * 
 * <p><b>Test Strategy:</b> Use real PostgreSQL database in Docker to verify:</p>
 * <ul>
 *   <li>Save/Find round-trip (domain → entity → domain)</li>
 *   <li>JSONB serialization (TransactionContext, List&lt;RoutingEvent&gt;)</li>
 *   <li>Cascade persist (challenges save with parent)</li>
 *   <li>Custom queries (findByCustomerId, findExpired)</li>
 * </ul>
 * 
 * @since Story 1.6
 */
@SpringBootTest
@Testcontainers
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class SignatureRequestRepositoryIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private SignatureRequestRepository repository;
    
    @Test
    void testSaveAndFindById() {
        // Given: Create domain model
        TransactionContext txContext = new TransactionContext(
            new Money(new BigDecimal("100.00"), "EUR"),
            "merchant-123",
            "order-456",
            "Payment for order 456",
            "a".repeat(64) // SHA256 hash
        );
        
        SignatureRequest request = SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId("customer-789")
            .transactionContext(txContext)
            .status(SignatureStatus.PENDING)
            .challenges(List.of())
            .routingTimeline(List.of())
            .createdAt(Instant.now())
            .expiresAt(Instant.now().plusSeconds(900))
            .build();
        
        // When: Save and reload
        SignatureRequest saved = repository.save(request);
        Optional<SignatureRequest> found = repository.findById(saved.getId());
        
        // Then: Verify round-trip
        assertThat(found).isPresent();
        assertThat(found.get().getCustomerId()).isEqualTo("customer-789");
        assertThat(found.get().getTransactionContext().amount().amount()).isEqualByComparingTo(new BigDecimal("100.00"));
        assertThat(found.get().getTransactionContext().merchantId()).isEqualTo("merchant-123");
    }
    
    @Test
    void testCascadePersistChallenges() {
        // Given: Create request with 2 challenges
        SignatureRequest request = SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId("customer-001")
            .transactionContext(createTestTransactionContext())
            .status(SignatureStatus.CHALLENGED)
            .challenges(List.of(
                SignatureChallenge.builder()
                    .id(UUIDGenerator.generateV7())
                    .channelType(ChannelType.SMS)
                    .provider(ProviderType.TWILIO)
                    .status(ChallengeStatus.PENDING)
                    .sentAt(Instant.now())
                    .build(),
                SignatureChallenge.builder()
                    .id(UUIDGenerator.generateV7())
                    .channelType(ChannelType.PUSH)
                    .provider(ProviderType.ONESIGNAL)
                    .status(ChallengeStatus.COMPLETED)
                    .sentAt(Instant.now())
                    .completedAt(Instant.now())
                    .build()
            ))
            .routingTimeline(List.of())
            .createdAt(Instant.now())
            .expiresAt(Instant.now().plusSeconds(900))
            .build();
        
        // When: Save and reload
        SignatureRequest saved = repository.save(request);
        Optional<SignatureRequest> found = repository.findById(saved.getId());
        
        // Then: Verify cascade persist
        assertThat(found).isPresent();
        assertThat(found.get().getChallenges()).hasSize(2);
        assertThat(found.get().getChallenges().get(0).getChannelType()).isEqualTo(ChannelType.SMS);
        assertThat(found.get().getChallenges().get(1).getStatus()).isEqualTo(ChallengeStatus.COMPLETED);
    }
    
    @Test
    void testJsonbSerializationTransactionContext() {
        // Given: Request with complex TransactionContext
        TransactionContext txContext = new TransactionContext(
            new Money(new BigDecimal("999.99"), "USD"),
            "merchant-special-chars-«ταƒ»",
            "order-unicode-中文",
            "Description with special chars: €£¥",
            "b".repeat(64)
        );
        
        SignatureRequest request = SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId("customer-002")
            .transactionContext(txContext)
            .status(SignatureStatus.PENDING)
            .challenges(List.of())
            .routingTimeline(List.of())
            .createdAt(Instant.now())
            .expiresAt(Instant.now().plusSeconds(900))
            .build();
        
        // When: Save and reload
        SignatureRequest saved = repository.save(request);
        Optional<SignatureRequest> found = repository.findById(saved.getId());
        
        // Then: Verify JSONB deserialization
        assertThat(found).isPresent();
        assertThat(found.get().getTransactionContext().merchantId()).isEqualTo("merchant-special-chars-«ταƒ»");
        assertThat(found.get().getTransactionContext().orderId()).isEqualTo("order-unicode-中文");
        assertThat(found.get().getTransactionContext().description()).contains("€£¥");
    }
    
    @Test
    void testUpdateExistingRequest() {
        // Given: Save initial request
        SignatureRequest request = SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId("customer-003")
            .transactionContext(createTestTransactionContext())
            .status(SignatureStatus.PENDING)
            .challenges(List.of())
            .routingTimeline(List.of())
            .createdAt(Instant.now())
            .expiresAt(Instant.now().plusSeconds(900))
            .build();
        
        SignatureRequest saved = repository.save(request);
        
        // When: Update status to SIGNED
        SignatureRequest updated = SignatureRequest.builder()
            .id(saved.getId())
            .customerId(saved.getCustomerId())
            .transactionContext(saved.getTransactionContext())
            .status(SignatureStatus.SIGNED)
            .challenges(saved.getChallenges())
            .routingTimeline(saved.getRoutingTimeline())
            .createdAt(saved.getCreatedAt())
            .expiresAt(saved.getExpiresAt())
            .signedAt(Instant.now())
            .build();
        
        repository.save(updated);
        Optional<SignatureRequest> found = repository.findById(saved.getId());
        
        // Then: Verify update
        assertThat(found).isPresent();
        assertThat(found.get().getStatus()).isEqualTo(SignatureStatus.SIGNED);
        assertThat(found.get().getSignedAt()).isNotNull();
    }
    
    @Test
    void testFindByCustomerId() {
        // Given: Save 2 requests for customer A, 1 for customer B
        String customerA = "customer-A";
        String customerB = "customer-B";
        
        repository.save(createTestRequest(customerA));
        repository.save(createTestRequest(customerA));
        repository.save(createTestRequest(customerB));
        
        // When: Query by customer A
        List<SignatureRequest> results = repository.findByCustomerId(customerA);
        
        // Then: Verify 2 requests returned
        assertThat(results).hasSize(2);
        assertThat(results).allMatch(r -> r.getCustomerId().equals(customerA));
    }
    
    @Test
    void testFindExpired() {
        // Given: Save 1 expired request (expiresAt in past), 1 active request (expiresAt in future)
        Instant past = Instant.now().minusSeconds(3600);
        Instant future = Instant.now().plusSeconds(900);
        
        SignatureRequest expired = SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId("customer-expired")
            .transactionContext(createTestTransactionContext())
            .status(SignatureStatus.PENDING)
            .challenges(List.of())
            .routingTimeline(List.of())
            .createdAt(past)
            .expiresAt(past)
            .build();
        
        SignatureRequest active = SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId("customer-active")
            .transactionContext(createTestTransactionContext())
            .status(SignatureStatus.PENDING)
            .challenges(List.of())
            .routingTimeline(List.of())
            .createdAt(Instant.now())
            .expiresAt(future)
            .build();
        
        repository.save(expired);
        repository.save(active);
        
        // When: Query expired
        List<SignatureRequest> results = repository.findExpired(Instant.now());
        
        // Then: Verify only expired request returned
        assertThat(results).hasSize(1);
        assertThat(results.get(0).getCustomerId()).isEqualTo("customer-expired");
    }
    
    // Helper methods
    private TransactionContext createTestTransactionContext() {
        return new TransactionContext(
            new Money(new BigDecimal("100.00"), "EUR"),
            "merchant-test",
            "order-test",
            "Test transaction",
            "c".repeat(64)
        );
    }
    
    private SignatureRequest createTestRequest(String customerId) {
        return SignatureRequest.builder()
            .id(UUIDGenerator.generateV7())
            .customerId(customerId)
            .transactionContext(createTestTransactionContext())
            .status(SignatureStatus.PENDING)
            .challenges(List.of())
            .routingTimeline(List.of())
            .createdAt(Instant.now())
            .expiresAt(Instant.now().plusSeconds(900))
            .build();
    }
}
        ]]></content>
      </artifact>
    </code>

    <dependencies>
      <maven>
        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-jpa</artifactId>
          <scope>compile</scope>
          <version>Managed by Spring Boot</version>
          <story>1.6</story>
          <note>Already included in Story 1.1, provides Spring Data JPA + Hibernate</note>
        </dependency>

        <dependency>
          <groupId>io.hypersistence</groupId>
          <artifactId>hypersistence-utils-hibernate-63</artifactId>
          <scope>compile</scope>
          <version>3.7.0</version>
          <story>1.6</story>
          <note>JSONB support for PostgreSQL with @Type(JsonBinaryType.class)</note>
        </dependency>

        <dependency>
          <groupId>com.fasterxml.jackson.core</groupId>
          <artifactId>jackson-databind</artifactId>
          <scope>compile</scope>
          <version>Managed by Spring Boot</version>
          <story>1.6</story>
          <note>Already included, used by mapper for JSON serialization/deserialization</note>
        </dependency>
      </maven>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="HEXA-1" type="architecture">
      <rule>Domain port interface (SignatureRequestRepository) DEBE estar en domain/port/outbound/ (NO en infrastructure/)</rule>
      <validation>ArchUnit test: classes in "..domain.port.outbound.." should not depend on "..infrastructure.."</validation>
    </constraint>

    <constraint id="HEXA-2" type="architecture">
      <rule>JPA entities (SignatureRequestEntity, SignatureChallengeEntity) NO DEBEN ser accedidas fuera de infrastructure/adapter/outbound/persistence/</rule>
      <validation>ArchUnit test: classes in "..persistence.entity.." should only be accessed by "..persistence.."</validation>
    </constraint>

    <constraint id="HEXA-3" type="architecture">
      <rule>Repository adapter DEBE implementar domain port interface (SignatureRequestRepository)</rule>
      <validation>ArchUnit test: classes named "*RepositoryAdapter" should implement interfaces in "..domain.port.outbound.."</validation>
    </constraint>

    <constraint id="PURITY-1" type="architecture">
      <rule>Domain port interface (SignatureRequestRepository) NO DEBE importar JPA, Spring, Jackson</rule>
      <validation>ArchUnit test: classes in "..domain.port.." should not depend on "..springframework..", "..jakarta.persistence..", "..fasterxml.jackson.."</validation>
    </constraint>

    <constraint id="JPA-1" type="implementation">
      <rule>JPA entities DEBEN usar @Entity, @Table, @Id annotations</rule>
      <validation>SignatureRequestEntity, SignatureChallengeEntity tienen annotations correctas</validation>
    </constraint>

    <constraint id="JPA-2" type="implementation">
      <rule>JSONB columns DEBEN usar @Type(JsonBinaryType.class) con hypersistence-utils</rule>
      <validation>transactionContextJson, routingTimelineJson, providerProofJson tienen @Type annotation</validation>
    </constraint>

    <constraint id="JPA-3" type="implementation">
      <rule>OneToMany relationship DEBE tener cascade = CascadeType.ALL, orphanRemoval = true</rule>
      <validation>SignatureRequestEntity.challenges tiene cascade ALL y orphanRemoval true</validation>
    </constraint>

    <constraint id="JPA-4" type="implementation">
      <rule>ManyToOne relationship DEBE tener @JoinColumn con foreign key name</rule>
      <validation>SignatureChallengeEntity.signatureRequest tiene @JoinColumn(name = "signature_request_id")</validation>
    </constraint>

    <constraint id="MAPPER-1" type="implementation">
      <rule>Mapper DEBE usar Jackson ObjectMapper para serialización/deserialización JSONB</rule>
      <validation>SignatureRequestEntityMapper usa objectMapper.writeValueAsString() y objectMapper.readValue()</validation>
    </constraint>

    <constraint id="MAPPER-2" type="implementation">
      <rule>Mapper DEBE convertir enums a String (toEntity) y String a enums (toDomain)</rule>
      <validation>SignatureStatus.name() → String, SignatureStatus.valueOf(string) → Enum</validation>
    </constraint>

    <constraint id="ADAPTER-1" type="implementation">
      <rule>Repository adapter DEBE estar anotado con @Component (Spring managed bean)</rule>
      <validation>SignatureRequestRepositoryAdapter tiene @Component annotation</validation>
    </constraint>

    <constraint id="ADAPTER-2" type="implementation">
      <rule>Repository adapter write methods DEBEN tener @Transactional (read-only = false)</rule>
      <validation>save(), delete() tienen @Transactional sin readOnly</validation>
    </constraint>

    <constraint id="ADAPTER-3" type="implementation">
      <rule>Repository adapter read methods DEBEN tener @Transactional(readOnly = true) para performance</rule>
      <validation>findById(), findByCustomerId(), findExpired() tienen @Transactional(readOnly = true)</validation>
    </constraint>

    <constraint id="TEST-1" type="testing">
      <rule>Integration tests DEBEN usar @SpringBootTest, @Testcontainers, @AutoConfigureTestDatabase(replace = NONE)</rule>
      <validation>SignatureRequestRepositoryIntegrationTest tiene annotations correctas</validation>
    </constraint>

    <constraint id="TEST-2" type="testing">
      <rule>Integration tests DEBEN usar PostgreSQLContainer real (NO H2 in-memory)</rule>
      <validation>@Container PostgreSQLContainer configurado con postgres:15-alpine</validation>
    </constraint>

    <constraint id="TEST-3" type="testing">
      <rule>Integration tests coverage > 80% para persistence package</rule>
      <validation>Ejecutar: mvn jacoco:report, verificar target/site/jacoco/index.html</validation>
    </constraint>

    <constraint id="DOC-1" type="documentation">
      <rule>JavaDoc MANDATORY para domain port interface (SignatureRequestRepository)</rule>
      <validation>Todos los métodos tienen JavaDoc con @param, @return</validation>
    </constraint>

    <constraint id="DOC-2" type="documentation">
      <rule>JavaDoc MANDATORY para repository adapter (SignatureRequestRepositoryAdapter)</rule>
      <validation>Clase tiene JavaDoc explicando Hexagonal Architecture pattern</validation>
    </constraint>
  </constraints>

  <interfaces>
    <interface id="IFC-1" name="SignatureRequestRepository (Domain Port)">
      <description>Domain port interface for persistence operations (Hexagonal Architecture outbound port)</description>
      <contract>
        - save(SignatureRequest): SignatureRequest - Save or update
        - findById(UUID): Optional&lt;SignatureRequest&gt; - Find by ID
        - findByCustomerId(String): List&lt;SignatureRequest&gt; - Find by customer
        - findExpired(Instant): List&lt;SignatureRequest&gt; - Find expired
        - delete(UUID): void - Delete by ID
      </contract>
      <location>domain/port/outbound/SignatureRequestRepository.java</location>
      <implementation>infrastructure/adapter/outbound/persistence/adapter/SignatureRequestRepositoryAdapter.java</implementation>
    </interface>

    <interface id="IFC-2" name="SignatureRequestJpaRepository (Spring Data JPA)">
      <description>Spring Data JPA repository interface (infrastructure component)</description>
      <contract>
        - Extends JpaRepository&lt;SignatureRequestEntity, UUID&gt; (provides CRUD methods)
        - findByIdWithChallenges(UUID): Optional&lt;SignatureRequestEntity&gt; - Eager loading with @EntityGraph
        - findByCustomerId(String): List&lt;SignatureRequestEntity&gt; - Query by customer
        - findByStatusAndExpiresAtBefore(String, Instant): List&lt;SignatureRequestEntity&gt; - Query expired
      </contract>
      <location>infrastructure/adapter/outbound/persistence/repository/SignatureRequestJpaRepository.java</location>
    </interface>

    <interface id="IFC-3" name="SignatureRequestEntityMapper (Bidirectional)">
      <description>Mapper for domain ↔ JPA entity conversions</description>
      <contract>
        - toEntity(SignatureRequest): SignatureRequestEntity - Domain → Entity
        - toDomain(SignatureRequestEntity): SignatureRequest - Entity → Domain
        - updateEntity(SignatureRequest, SignatureRequestEntity): void - Update existing entity
      </contract>
      <location>infrastructure/adapter/outbound/persistence/mapper/SignatureRequestEntityMapper.java</location>
    </interface>
  </interfaces>

  <tests>
    <standards>
      <standard id="TS-1">Integration tests MANDATORY con Testcontainers PostgreSQL (NO H2)</standard>
      <standard id="TS-2">Test save/findById round-trip (domain → entity → domain, verificar equality)</standard>
      <standard id="TS-3">Test JSONB serialization (TransactionContext, List&lt;RoutingEvent&gt;, ProviderResult)</standard>
      <standard id="TS-4">Test cascade persist (challenges save automáticamente con parent)</standard>
      <standard id="TS-5">Test custom queries (findByCustomerId, findExpired)</standard>
      <standard id="TS-6">ArchUnit tests para Hexagonal Architecture enforcement (domain port purity, infrastructure isolation)</standard>
      <standard id="TS-7">Test coverage > 80% para persistence package (JaCoCo report)</standard>
    </standards>

    <locations>
      <location>src/test/java/com/bank/signature/infrastructure/adapter/outbound/persistence/SignatureRequestRepositoryIntegrationTest.java</location>
      <location>src/test/java/com/bank/signature/HexagonalArchitectureTest.java (update existing with 3 new tests)</location>
    </locations>

    <ideas>
      <test id="TEST-1" maps_to="AC7">
        <name>testSaveAndFindById</name>
        <approach>Create SignatureRequest domain model, save via repository adapter, find by ID, verify TransactionContext fields match (round-trip validation)</approach>
      </test>

      <test id="TEST-2" maps_to="AC7">
        <name>testCascadePersistChallenges</name>
        <approach>Create SignatureRequest with 2 SignatureChallenge entities, save via repository, find by ID, verify 2 challenges persisted with correct channelType/status</approach>
      </test>

      <test id="TEST-3" maps_to="AC7">
        <name>testJsonbSerializationTransactionContext</name>
        <approach>Create SignatureRequest with TransactionContext containing special chars (unicode, €£¥), save and reload, verify JSONB deserialization correct</approach>
      </test>

      <test id="TEST-4" maps_to="AC7">
        <name>testUpdateExistingRequest</name>
        <approach>Save SignatureRequest with status PENDING, update status to SIGNED + signedAt, save again, find by ID, verify status updated</approach>
      </test>

      <test id="TEST-5" maps_to="AC7">
        <name>testFindByCustomerId</name>
        <approach>Save 2 requests for customer A, 1 for customer B, call findByCustomerId("customer-A"), verify 2 results returned</approach>
      </test>

      <test id="TEST-6" maps_to="AC7">
        <name>testFindExpired</name>
        <approach>Save 1 expired request (expiresAt in past), 1 active request (expiresAt in future), call findExpired(Instant.now()), verify only expired request returned</approach>
      </test>

      <test id="TEST-7" maps_to="AC10">
        <name>ArchUnit: Domain Ports Should Not Depend On Infrastructure</name>
        <approach>ArchUnit rule: classes in "..domain.port.." should not depend on "..springframework..", "..jakarta.persistence..", "..fasterxml.jackson..", verify no violations</approach>
      </test>

      <test id="TEST-8" maps_to="AC10">
        <name>ArchUnit: Infrastructure Should Not Leak To Application</name>
        <approach>ArchUnit rule: classes in "..persistence.entity.." should only be accessed by "..persistence..", verify JPA entities NOT accessed outside persistence package</approach>
      </test>

      <test id="TEST-9" maps_to="AC10">
        <name>ArchUnit: Repository Adapter Should Implement Domain Port</name>
        <approach>ArchUnit rule: classes named "*RepositoryAdapter" should implement interfaces in "..domain.port.outbound..", verify SignatureRequestRepositoryAdapter implements SignatureRequestRepository</approach>
      </test>
    </ideas>
  </tests>

  <implementation_notes>
    <priority level="CRITICAL">
      <note>Domain Port Interface PRIMERO: Crear SignatureRequestRepository en domain/port/outbound/ ANTES de cualquier código infrastructure (Hexagonal Architecture enforcement)</note>
      <note>JSONB Serialization: @Type(JsonBinaryType.class) requiere hypersistence-utils-hibernate-63 dependency (NO incluido por defecto)</note>
      <note>Cascade ALL + orphanRemoval: SignatureRequestEntity.challenges DEBE tener cascade = CascadeType.ALL, orphanRemoval = true (challenges persisten/borran con parent)</note>
      <note>Transactional Boundaries: Repository adapter DEBE tener @Transactional en save/delete (writes), @Transactional(readOnly = true) en findById/findByCustomerId (reads)</note>
    </priority>

    <priority level="HIGH">
      <note>Jackson ObjectMapper: Mapper usa Jackson para JSONB serialization (TransactionContext → JSON String, List&lt;RoutingEvent&gt; → JSON Array)</note>
      <note>Enum Mapping: SignatureStatus.name() → String (toEntity), SignatureStatus.valueOf(string) → Enum (toDomain)</note>
      <note>EntityGraph Eager Loading: SignatureRequestJpaRepository.findByIdWithChallenges usa @EntityGraph(attributePaths = {"challenges"}) para evitar N+1 queries</note>
      <note>Testcontainers PostgreSQL 15: Integration tests DEBEN usar PostgreSQLContainer real (NO H2 in-memory, diferente dialecto SQL)</note>
      <note>ArchUnit Tests: Agregar 3 tests para validar domain port purity, infrastructure isolation, adapter contract</note>
    </priority>

    <priority level="MEDIUM">
      <note>FetchType.LAZY: SignatureRequestEntity.challenges usa fetch = LAZY (performance, challenges cargados solo cuando necesarios)</note>
      <note>Bidirectional Mapping: SignatureChallengeEntity.signatureRequest (back-reference) DEBE tener @ManyToOne</note>
      <note>Update Strategy: Mapper.updateEntity() para updates eficientes (NO recrear entity completa)</note>
      <note>Error Handling: Mapper lanza RuntimeException con JsonProcessingException cause (simplifica error handling en adapter)</note>
    </priority>

    <priority level="LOW">
      <note>Future MapStruct: Considerar reemplazar manual mapping con MapStruct (compile-time generation, mejor performance, menos boilerplate)</note>
      <note>Future Optimistic Locking: Agregar @Version field para prevenir lost updates (concurrency)</note>
      <note>Future Soft Delete: Agregar deletedAt field para soft deletes (audit trail)</note>
    </priority>
  </implementation_notes>

  <definition_of_done>
    <checklist>
      <item>Code Complete: SignatureRequestRepository interface creada en domain/port/outbound/ (5 métodos: save, findById, findByCustomerId, findExpired, delete)</item>
      <item>Code Complete: SignatureRequestEntity creada con @Entity, @Table, @Type(JsonBinaryType.class) para JSONB columns</item>
      <item>Code Complete: SignatureChallengeEntity creada con @Entity, @Table, @ManyToOne back-reference</item>
      <item>Code Complete: SignatureRequestJpaRepository creada extends JpaRepository (3 custom queries)</item>
      <item>Code Complete: SignatureRequestEntityMapper creada con toEntity, toDomain, updateEntity métodos</item>
      <item>Code Complete: SignatureChallengeEntityMapper creada (similar)</item>
      <item>Code Complete: SignatureRequestRepositoryAdapter creada implements SignatureRequestRepository</item>
      <item>Tests Passing: SignatureRequestRepositoryIntegrationTest con 6 test methods (testSaveAndFindById, testCascadePersistChallenges, testJsonbSerializationTransactionContext, testUpdateExistingRequest, testFindByCustomerId, testFindExpired)</item>
      <item>Tests Passing: HexagonalArchitectureTest actualizado con 3 nuevos tests (domainPortsShouldNotDependOnInfrastructure, infrastructureShouldNotLeakToApplication, repositoryAdapterShouldImplementDomainPort)</item>
      <item>Tests Passing: Test coverage > 80% para persistence package (JaCoCo report)</item>
      <item>Architecture Validated: Domain port interface en domain/port/outbound/ (NO en infrastructure/)</item>
      <item>Architecture Validated: JPA entities NO accedidas fuera de persistence package (ArchUnit test pasa)</item>
      <item>Architecture Validated: Repository adapter implementa domain port interface (ArchUnit test pasa)</item>
      <item>Dependency Added: io.hypersistence:hypersistence-utils-hibernate-63 version 3.7.0 en pom.xml</item>
      <item>Transactional Behavior Configured: save/delete con @Transactional, findById/findByCustomerId con @Transactional(readOnly = true)</item>
      <item>JSONB Serialization Validated: TransactionContext, List&lt;RoutingEvent&gt;, ProviderResult serializan/deserializan correctamente (integration test pasa)</item>
      <item>Cascade Persist Validated: Challenges persisten automáticamente con parent (testCascadePersistChallenges pasa)</item>
      <item>Documentation Updated: README.md con sección "Persistence Layer (JPA)" (package structure, usage example, JSONB notes)</item>
      <item>Documentation Updated: CHANGELOG.md con Story 1.6 entry (JPA entities, repository adapter, JSONB support, 6 integration tests)</item>
      <item>Documentation Updated: JavaDoc en SignatureRequestRepository interface (métodos con @param, @return)</item>
      <item>Documentation Updated: JavaDoc en SignatureRequestRepositoryAdapter (Hexagonal Architecture notes)</item>
      <item>Code Review Approved: Domain port purity maintained (NO imports JPA/Spring/Jackson en domain/port/outbound/)</item>
      <item>Code Review Approved: Hexagonal Architecture pattern correct (adapter implements port, retorna domain models)</item>
      <item>Code Review Approved: JSONB serialization strategy clear (Jackson ObjectMapper, transactionContextJson String)</item>
      <item>Story Marked as Done: Todos los 12 ACs verificados</item>
      <item>Story Marked as Done: Sprint status actualizado a done</item>
    </checklist>
  </definition_of_done>
</story-context>
